{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./demo.ts","webpack:///./src/Seen2.ts","webpack:///./src/camera.ts","webpack:///./src/color.ts","webpack:///./src/light.ts","webpack:///./src/materials.ts","webpack:///./src/model.ts","webpack:///./src/point.ts","webpack:///./src/render/canvas.ts","webpack:///./src/render/rendermodel.ts","webpack:///./src/scene.ts","webpack:///./src/shapes/primitives.ts","webpack:///./src/surface.ts","webpack:///./src/transformable.ts","webpack:///./src/util.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAA2C;AAC3C;AAC0D;AAC1D,UAAU,EAAE;AACsC;AAClD;AACA;AACA;AACA,cAAc,sEAAmB;AACjC;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAK;AACrB,YAAY,sEAAO;AACnB,gBAAgB,gDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,wCAAwC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;;;;;;;;;;;ACxCJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,cAAc,cAAc;AACI;AACA;AACgB;AACZ;AACF;AACN;;;;;;;;;;;;;ACT5B;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,+BAA+B,WAAW;AAC1C,gCAAgC,aAAa;AAC7C,6BAA6B,SAAS;AACtC,8BAA8B,UAAU;AACxC,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAC,IAAI;AACpB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,+BAA+B,WAAW;AAC1C,gCAAgC,aAAa;AAC7C,6BAA6B,SAAS;AACtC,8BAA8B,UAAU;AACxC,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA,oBAAoB,4DAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAC,IAAI;AACpB;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C,gCAAgC,cAAc;AAC9C,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,4BAA4B,qDAAM;AAClC;AACA;AACA,6BAA6B,qDAAM;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C,gCAAgC,cAAc;AAC9C,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,4BAA4B,4DAAa;AACzC;AACA;AACA;AACA,6BAA6B,4DAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACG;;;;;;;;;;;;;AC1JlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE,yCAAyC,6BAA6B;AACtE,wCAAwC,6BAA6B;AACrE;AACA,CAAC;AACgB;;;;;;;;;;;;;AC7KjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC+C;AACb;AACH;AACF;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAK;AAC/B,0BAA0B,4CAAK;AAC/B,6BAA6B;AAC7B;AACA,uBAAuB,gDAAC;AACxB;AACA,mBAAmB,0CAAI;AACvB,QAAQ,0CAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iCAAiC;AAC/E;AACA;AACA;AACA,oDAAoD,uCAAuC;AAC3F;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA,CAAC;AACiB;;;;;;;;;;;;;ACxDlB;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC8B;AACE;AAChC;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B,QAAQ,0CAAI;AACZ;AACA;AACA;AACA;AACA,kCAAkC,4CAAK;AACvC;AACA;AACA,6BAA6B,4CAAK,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;;;;;;;;;;;;;AChDpB;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC+C;AAChB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACE;;;;;;;;;;;;;AChDjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;;;;;;;;;;;;;AC7IP;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAyC;AACzC;AACA;AACA,qBAAqB,gDAAC,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uCAAuC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAU;AAChC;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC7DD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACgC;AACY;AACO;AACH;AAChD;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAK,CAAC,oEAAS;AACxC;AACA;AACA,0BAA0B,8CAAM;AAChC;AACA;AACA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAW;AAClC;AACA;AACA,mEAAmE,+DAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgB;;;;;;;;;;;;;ACvIjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC6B;AACe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACO;AACP,kBAAkB,gDAAC,WAAW,gDAAC,WAAW,gDAAC;AAC3C,eAAe,8CAAK;AACpB;AACO;AACP,kBAAkB,gDAAC,cAAc,gDAAC,aAAa,gDAAC,aAAa,gDAAC,YAAY,gDAAC,aAAa,gDAAC,YAAY,gDAAC,YAAY,gDAAC;AACnH,eAAe,8CAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACC;AACP,kBAAkB,gDAAC,WAAW,gDAAC,WAAW,gDAAC,WAAW,gDAAC,WAAW,gDAAC;AACnE,eAAe,8CAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAA6C,6BAA6B,iBAAiB;AACnH;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAO;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC6B;AACS;AACS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA;AACA,gCAAgC,mDAAQ;AACxC;AACA;AACA;AACA,kCAAkC,mDAAQ;AAC1C;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACE;;;;;;;;;;;;;AC3EjB;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,uBAAuB,OAAO;AAC9B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACiB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5LA;AAAA;AAAA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACe","file":"seen_ts.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./demo.ts\");\n","import { Scene, Model } from \"./src/Seen2\";\r\n// this will be somewhere else....\r\nimport { CanvasRenderContext } from \"./src/render/canvas\";\r\n//import {P} from \"./src/point\"\r\nimport { pyramid } from './src/shapes/primitives';\r\nconsole.log('I am ALIVE');\r\nvar width = 900;\r\nvar height = 500;\r\nvar ctx = new CanvasRenderContext('seen-canvas');\r\n// // create a cube\r\n// let shape = Cube()\r\n// console.log('shape',shape)\r\n// shape.render()\r\n// Create scene and add cube to model\r\nvar scene = new Scene();\r\nvar shape = pyramid();\r\nvar model = new Model(shape);\r\nscene.model = model;\r\nscene.render();\r\n// let viewport = new Viewport.center(width, height)\r\n// Create sphere shape with randomly colored surfaces\r\n//let shape = seen.Shapes.sphere(2).scale(height * 0.4)\r\n//let shape = Shapes.cube().scale(height * 0.2)\r\n//let shape = new Shapes().pyramid()//.scale(height * 0.2)\r\n////////////// this works\r\n// let points = [P(-1, -1, -1), P(-1, -1, 1), P(-1, 1, -1), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];\r\n// points = [P(10,10,10), P(20,20,20), P(10,20,30), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];\r\n// //console.log(points);\r\n// ctx.path(points);\r\n// ctx.fill({fillStyle: 'yellow'})\r\n// ctx.draw({strokeStyle:'rgb(0,128,0)',lineWidth: 3})\r\n// console.log('done')\r\n///////////////////\r\n//seen.Colors.randomSurfaces2(shape)\r\n//console.log(shape)\r\n// // Create render context from canvas\r\n// let context = seen.Context('seen-canvas', scene).render()\r\n// // Slowly rotate\r\n// context.animate().onBefore(function (t, dt) {\r\n//   return shape.rotx(dt * 1e-3).roty(0.7 * dt * 1e-3);\r\n// }).start();\r\n","// Aggregate submodules together in a parent module.\r\n//\r\n// supports\r\n//    import {Scene, Matrix} from 'seen'\r\nexport { Scene } from './scene';\r\nexport { Model } from './model';\r\nexport { Primitive } from './shapes/primitives';\r\nexport { Viewport } from \"./camera\"; // TODO: should this be exported, or is it just part of camera?\r\nexport { Shape } from './surface';\r\nexport { P } from './point';\r\n","// //// Camera\r\n// //////// Projections, Viewports, and Cameras\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { M, Matrix, Transformable } from './transformable';\r\n// These projection methods return a 3D to 2D `Matrix` transformation.\r\n// Each projection assumes the camera is located at (0,0,0).\r\nvar Projection = /** @class */ (function () {\r\n    function Projection() {\r\n    }\r\n    // Creates a perspective projection matrix\r\n    Projection.perspectiveFov = function (fovyInDegrees, front) {\r\n        if (fovyInDegrees === void 0) { fovyInDegrees = 50; }\r\n        if (front === void 0) { front = 1; }\r\n        var tan = front * Math.tan(fovyInDegrees * Math.PI / 360.0);\r\n        return this.perspective(-tan, tan, -tan, tan, front, 2 * front);\r\n    };\r\n    /** Creates a perspective projection matrix with the supplied frustrum */\r\n    Projection.perspective = function (left, right, bottom, top, near, far) {\r\n        if (left === void 0) { left = -1; }\r\n        if (right === void 0) { right = 1; }\r\n        if (bottom === void 0) { bottom = -1; }\r\n        if (top === void 0) { top = 1; }\r\n        if (near === void 0) { near = 1; }\r\n        if (far === void 0) { far = 100; }\r\n        var near2 = 2 * near;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        var m = new Array(16);\r\n        m[0] = near2 / dx;\r\n        m[1] = 0.0;\r\n        m[2] = (right + left) / dx;\r\n        m[3] = 0.0;\r\n        m[4] = 0.0;\r\n        m[5] = near2 / dy;\r\n        m[6] = (top + bottom) / dy;\r\n        m[7] = 0.0;\r\n        m[8] = 0.0;\r\n        m[9] = 0.0;\r\n        m[10] = -(far + near) / dz;\r\n        m[11] = -(far * near2) / dz;\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = -1.0;\r\n        m[15] = 0.0;\r\n        return M(m); // Matrix class\r\n    };\r\n    /** Creates a orthographic projection matrix with the supplied frustrum */\r\n    Projection.ortho = function (left, right, bottom, top, near, far) {\r\n        if (left === void 0) { left = -1; }\r\n        if (right === void 0) { right = 1; }\r\n        if (bottom === void 0) { bottom = -1; }\r\n        if (top === void 0) { top = 1; }\r\n        if (near === void 0) { near = 1; }\r\n        if (far === void 0) { far = 100; }\r\n        var near2 = 2 * near;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        var t = new Transformable;\r\n        var m = new Array(16);\r\n        m[0] = 2 / dx;\r\n        m[1] = 0.0;\r\n        m[2] = 0.0;\r\n        m[3] = (right + left) / dx;\r\n        m[4] = 0.0;\r\n        m[5] = 2 / dy;\r\n        m[6] = 0.0;\r\n        m[7] = -(top + bottom) / dy;\r\n        m[8] = 0.0;\r\n        m[9] = 0.0;\r\n        m[10] = -2 / dz;\r\n        m[11] = -(far + near) / dz;\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = 0.0;\r\n        m[15] = 1.0;\r\n        return M(m); // matrix class\r\n    };\r\n    return Projection;\r\n}());\r\nexport { Projection };\r\nvar Viewport = /** @class */ (function () {\r\n    function Viewport() {\r\n        this.center(500, 500, 0, 0);\r\n    }\r\n    /** Create a viewport where the scene's origin is centered in the view */\r\n    Viewport.prototype.center = function (width, height, x, y) {\r\n        if (width === void 0) { width = 500; }\r\n        if (height === void 0) { height = 500; }\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        this.prescale = new Matrix()\r\n            .translate(-x, -y, -height)\r\n            .scale(1 / width, 1 / height, 1 / height);\r\n        this.postscale = new Matrix()\r\n            .scale(width, -height, height)\r\n            .translate(x + width / 2, y + height / 2, height);\r\n    };\r\n    /** Create a view port where the scene's origin is aligned with the origin ([0, 0]) of the view */\r\n    Viewport.prototype.origin = function (width, height, x, y) {\r\n        if (width === void 0) { width = 500; }\r\n        if (height === void 0) { height = 500; }\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        this.prescale = new Transformable()\r\n            .m\r\n            .translate(-x, -y, -1)\r\n            .scale(1 / width, 1 / height, 1 / height);\r\n        this.postscale = new Transformable()\r\n            .m\r\n            .scale(width, -height, height)\r\n            .translate(x, y);\r\n        return this;\r\n    };\r\n    return Viewport;\r\n}());\r\nexport { Viewport };\r\n// The `Camera` model contains all three major components of the 3D to 2D tranformation.\r\n//\r\n// First, we transform object from world-space (the same space that the coordinates of\r\n// surface points are in after all their transforms are applied) to camera space. Typically,\r\n// this will place all viewable objects into a cube with coordinates:\r\n// x = -1 to 1, y = -1 to 1, z = 1 to 2\r\n//\r\n// Second, we apply the projection trasform to create perspective parallax and what not.\r\n//\r\n// Finally, we rescale to the viewport size.\r\n//\r\n// These three steps allow us to easily create shapes whose coordinates match up to\r\n// screen coordinates in the z = 0 plane.\r\nvar Camera = /** @class */ (function (_super) {\r\n    __extends(Camera, _super);\r\n    function Camera(options) {\r\n        var _this = _super.call(this) || this;\r\n        //seen.Util.defaults(this., options, this.defaults)\r\n        _this.m = Projection.perspective();\r\n        return _this;\r\n    }\r\n    return Camera;\r\n}(Transformable));\r\nexport { Camera };\r\n","// //// Colors\r\n// ------------------\r\n/** `Color` objects store RGB and Alpha values from 0 to 255. Default is gray. */\r\nvar Color = /** @class */ (function () {\r\n    function Color(hexString) {\r\n        if (hexString) {\r\n            return this.hex(hexString);\r\n        }\r\n        else {\r\n            // consider supporting 140 names from https://htmlcolorcodes.com/\r\n            // default is gray    \r\n            return (this.hex('//888888'));\r\n        }\r\n    }\r\n    /** Returns a new `Color` object with the same rgb and alpha values as the current object */\r\n    Color.prototype.copy = function () {\r\n        return new Color(this.hexString());\r\n    };\r\n    /** Scales the rgb channels by the supplied scalar value. */\r\n    Color.prototype.scale = function (n) {\r\n        this.r *= n;\r\n        this.g *= n;\r\n        this.b *= n;\r\n        return this;\r\n    };\r\n    /** Offsets each rgb channel by the supplied scalar value. */\r\n    Color.prototype.offset = function (n) {\r\n        this.r += n;\r\n        this.g += n;\r\n        this.b += n;\r\n        return this;\r\n    };\r\n    /** Clamps each rgb channel to the supplied minimum and maximum scalar values. */\r\n    Color.prototype.clamp = function (min, max) {\r\n        if (min === void 0) { min = 0; }\r\n        if (max === void 0) { max = 0xFF; }\r\n        this.r = Math.min(max, Math.max(min, this.r));\r\n        this.g = Math.min(max, Math.max(min, this.g));\r\n        this.b = Math.min(max, Math.max(min, this.b));\r\n        return this;\r\n    };\r\n    /** Takes the minimum between each channel of this `Color` and the supplied `Color` object. */\r\n    Color.prototype.minChannels = function (c) {\r\n        this.r = Math.min(c.r, this.r);\r\n        this.g = Math.min(c.g, this.g);\r\n        this.b = Math.min(c.b, this.b);\r\n        return this;\r\n    };\r\n    /** Adds the channels of the current `Color` with each respective channel from the supplied `Color` object. */\r\n    Color.prototype.addChannels = function (c) {\r\n        this.r += c.r;\r\n        this.g += c.g;\r\n        this.b += c.b;\r\n        return this;\r\n    };\r\n    /** Multiplies the channels of the current `Color` with each respective channel from the supplied `Color` object. */\r\n    Color.prototype.multiplyChannels = function (c) {\r\n        this.r *= c.r;\r\n        this.g *= c.g;\r\n        this.b *= c.b;\r\n        return this;\r\n    };\r\n    /** Converts the `Color` into a hex string of the form \"//RRGGBB\". */\r\n    Color.prototype.hexString = function () {\r\n        var c = (this.r << 16 | this.g << 8 | this.b).toString(16);\r\n        while (c.length < 6) {\r\n            c = '0' + c;\r\n        }\r\n        return '//' + c;\r\n    };\r\n    // Converts the `Color` into a CSS-style string of the form \"rgba(RR, GG, BB, AA)\"\r\n    Color.prototype.style = function () {\r\n        return \"rgba(//{this.r},//{this.g},//{this.b},//{this.a})\";\r\n    };\r\n    // Parses a hex string starting with an octothorpe (//) or an rgb/rgba CSS\r\n    // string. Note that the CSS rgba format uses a float value of 0-1.0 for\r\n    /** alpha, but seen uses an in from 0-255. */\r\n    Color.prototype.parse = function (str) {\r\n        if (str.charAt(0) === '#' && str.length === 7) {\r\n            return this.hex(str);\r\n        }\r\n        else if (str.indexOf('rgb') === 0) {\r\n            var m = this.CSS_RGBA_STRING_REGEX.exec(str);\r\n            if (m == null) {\r\n                return this.black();\r\n            }\r\n            var a = m[6] != null ? Math.round(parseFloat(m[6]) * 0xFF) : void 0;\r\n            return this.rgb(parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), a);\r\n        }\r\n        else {\r\n            return this.black();\r\n        }\r\n    };\r\n    /** Loads the  `Color` using the supplied rgb and alpha values.\r\n    Each value must be in the range [0, 255] or, equivalently, [0x00, 0xFF]. */\r\n    Color.prototype.rgb = function (r, g, b, a) {\r\n        if (a === void 0) { a = 0xFF; }\r\n        this.r = r;\r\n        this.b = b;\r\n        this.g = g;\r\n        this.a = a;\r\n        return this;\r\n    };\r\n    // Creates a new `Color` using the supplied hex string of the form \"//RRGGBB\".\r\n    Color.prototype.hex = function (hex) {\r\n        if (hex.charAt(0) == '//')\r\n            hex = hex.substring(1);\r\n        this.r = parseInt(hex.substring(0, 2), 16);\r\n        this.b = parseInt(hex.substring(2, 4), 16);\r\n        this.g = parseInt(hex.substring(4, 6), 16);\r\n        return this;\r\n    };\r\n    /** Creates a new `Color` using the supplied hue, saturation, and lightness (HSL) values.\r\n     Each value must be in the range [0.0, 1.0]. */\r\n    Color.prototype.hsl = function (h, s, l, a) {\r\n        if (a === void 0) { a = 1; }\r\n        var r, g, b;\r\n        r = g = b = 0;\r\n        if (s == 0) // When saturation is 0, the color is \"achromatic\" or \"grayscale\".\r\n            r = g = b = l;\r\n        else {\r\n            var q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\r\n            var p = 2 * l - q;\r\n            r = this.hue2rgb(p, q, h + 1 / 3);\r\n            g = this.hue2rgb(p, q, h);\r\n            b = this.hue2rgb(p, q, h - 1 / 3);\r\n        }\r\n        return this.rgb(r * 255, g * 255, b * 255, a * 255);\r\n    };\r\n    Color.prototype.hue2rgb = function (p, q, t) {\r\n        if (t < 0) {\r\n            t += 1;\r\n        }\r\n        else if (t > 1) {\r\n            t -= 1;\r\n        }\r\n        if (t < 1 / 6) {\r\n            return p + (q - p) * 6 * t;\r\n        }\r\n        else if (t < 1 / 2) {\r\n            return q;\r\n        }\r\n        else if (t < 2 / 3) {\r\n            return p + (q - p) * (2 / 3 - t) * 6;\r\n        }\r\n        else {\r\n            return p;\r\n        }\r\n    };\r\n    // /** Generates a new random color for each surface of the supplied `Shape`. */\r\n    // randomSurfaces(shape: Shape, sat: number = 0.5, lit: number = 0.4) {\r\n    //     shape.forEach(element => {\r\n    //         surface.fill(Colors.hsl(Math.random(), sat, lit))\r\n    //     })\r\n    // }\r\n    //   // Generates a random hue then randomly drifts the hue for each surface of\r\n    //   // the supplied `Shape`.\r\n    //   randomSurfaces2 : (shape, drift = 0.03, sat = 0.5, lit = 0.4) ->\r\n    //     hue = Math.random()\r\n    //     for surface in shape.surfaces\r\n    //       hue += (Math.random() - 0.5) * drift\r\n    //       while hue < 0 then hue += 1\r\n    //       while hue > 1 then hue -= 1\r\n    //       surface.fill seen.Colors.hsl(hue, 0.5, 0.4)\r\n    //   /** Generates a random color then sets the fill for every surface of the supplied `Shape`. */\r\n    //   randomShape : (shape:Shape, sat:number = 0.5, lit:number = 0.4) ->\r\n    //     shape.fill (new Material (this.hsl(Math.random()), sat, lit)\r\n    // A few `Color`s are supplied for convenience.\r\n    Color.prototype.black = function () { return this.hex('//000000'); };\r\n    Color.prototype.white = function () { return this.hex('//FFFFFF'); };\r\n    Color.prototype.gray = function () { return this.hex('//888888'); };\r\n    return Color;\r\n}());\r\nexport { Color };\r\n","// //// Lights\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Transformable } from './transformable';\r\nimport { P, Point } from './point';\r\nimport { Color } from './color';\r\nimport { Util } from './util';\r\n// This model object holds the attributes and transformation of a light source.\r\nvar Light = /** @class */ (function (_super) {\r\n    __extends(Light, _super);\r\n    function Light(type, options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.point = new Point();\r\n        _this.color = new Color().white();\r\n        _this.type = 'point'; // directional, ambient\r\n        _this.intensity = 0.01;\r\n        _this.normal = P(1, -1, -1).normalize();\r\n        _this.enabled = true;\r\n        _this.id = Util.uniqueId('L');\r\n        Util.defaults(_this, options, _this.defaults);\r\n        return _this;\r\n    }\r\n    Light.prototype.render = function () {\r\n        this.colorIntensity = this.color.copy().scale(this.intensity);\r\n    };\r\n    return Light;\r\n}(Transformable));\r\nexport { Light };\r\nvar Lights = /** @class */ (function () {\r\n    function Lights() {\r\n    }\r\n    // A point light emits light eminating in all directions from a single point.\r\n    // The `point` property determines the location of the point light. Note,\r\n    // though, that it may also be moved through the transformation of the light.\r\n    Lights.prototype.point = function (opts) { return new Light('point', opts); };\r\n    // A directional lights emit light in parallel lines, not eminating from any\r\n    // single point. For these lights, only the `normal` property is used to\r\n    // determine the direction of the light. This may also be transformed.\r\n    Lights.prototype.directional = function (opts) { return new Light('directional', opts); };\r\n    // Ambient lights emit a constant amount of light everywhere at once.\r\n    // Transformation of the light has no effect.\r\n    Lights.prototype.ambient = function (opts) { return new Light('ambient', opts); };\r\n    return Lights;\r\n}());\r\nexport { Lights };\r\n","// //// Materials\r\n// //////// Surface material properties\r\n// ------------------\r\nimport { Util } from './util';\r\nimport { Color } from './color';\r\n// `Material` objects hold the attributes that describe the color and finish of a surface.\r\nvar Material = /** @class */ (function () {\r\n    function Material(color, options) {\r\n        if (options === void 0) { options = {}; }\r\n        // The `metallic` attribute determines how the specular highlights are\r\n        // calculated. Normally, specular highlights are the color of the light\r\n        // source. If metallic is true, specular highlight colors are determined\r\n        // from the `specularColor` attribute.\r\n        this.metallic = false;\r\n        // The color used for specular highlights when `metallic` is true.\r\n        this.specularColor = new Color().white();\r\n        // The `specularExponent` determines how \"shiny\" the material is. A low\r\n        // exponent will create a low-intesity, diffuse specular shine. A high\r\n        // exponent will create an intense, point-like specular shine.\r\n        this.specularExponent = 15;\r\n        // A `Shader` object may be supplied to override the shader used for this\r\n        // material. For example, if you want to apply a flat color to text or\r\n        // other shapes, set this value to `seen.Shaders.Flat`.\r\n        this.shader = null; // TODO:\r\n        this.color = 'gray'; //Colors.gray()\r\n        Util.defaults(this, options, this.defaults);\r\n    }\r\n    Material.prototype.create = function (value) {\r\n        if (value instanceof Material)\r\n            return value;\r\n        else if (value instanceof Color)\r\n            return new Material(value);\r\n        else if (typeof (value) == 'string') {\r\n            this.color = new Color(value); //.parse(value))   \r\n            return this;\r\n        }\r\n        else\r\n            return this;\r\n    };\r\n    // Apply the shader's shading to this material, with the option to override\r\n    // the shader with the material's shader (if defined).\r\n    Material.prototype.render = function (lights, shader, renderData) {\r\n        var color = shader.shade(lights, renderData, this);\r\n        color.a = this.color.a;\r\n        return color;\r\n    };\r\n    return Material;\r\n}());\r\nexport { Material };\r\n","// //// Models\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Transformable } from './transformable';\r\nimport { Light } from './light';\r\n// The object model class. It stores `Shapes` and `Lights`\r\n// TODO: move lights to somewhere else\r\n// Notably, models are hierarchical, like a tree. This means you can isolate\r\n// the transformation of groups of shapes in the scene, as well as create\r\n// chains of transformations for creating, for example, articulated skeletons.\r\nvar Model = /** @class */ (function (_super) {\r\n    __extends(Model, _super);\r\n    function Model(shape) {\r\n        var _this = _super.call(this) || this;\r\n        _this.models = [];\r\n        _this.lights = [];\r\n        _this.surfaces = [];\r\n        _this.shape = shape;\r\n        return _this;\r\n    }\r\n    /** Add a `Shape`, `Light`, and other `Model` as a child of this `Model`\r\n     *Any number of children can by supplied as arguments.   */\r\n    Model.prototype.addChild = function (child) {\r\n        if (child instanceof Light) {\r\n            this.lights.push(child);\r\n        }\r\n        else if (child instanceof Model) {\r\n            this.models.push(child);\r\n        }\r\n        else { // must be a surface\r\n            this.surfaces.push(child);\r\n        }\r\n        return this;\r\n    };\r\n    return Model;\r\n}(Transformable));\r\nexport { Model };\r\n","// The `Point` object contains x,y,z, and w coordinates. `Point`s support\r\n// various arithmetic operations with other `Points`, scalars, or `Matrices`.\r\n//\r\n// Most of the methods on `Point` are destructive, so be sure to use `.copy()`\r\n// when you want to preserve an object's value.\r\n/**  Convenience method for creating a new `Point` object*/\r\nexport function P(x, y, z, w) {\r\n    if (w === void 0) { w = 1; }\r\n    return (new Point(x, y, z, w));\r\n}\r\nvar Point = /** @class */ (function () {\r\n    function Point(x, y, z, w) {\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        if (z === void 0) { z = 0; }\r\n        if (w === void 0) { w = 1; }\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n    }\r\n    /** Creates and returns a new `Point` with the same values as this object. */\r\n    Point.prototype.copy = function () {\r\n        return P(this.x, this.y, this.z, this.w);\r\n    };\r\n    /** Copies the values of the supplied `Point` into this object. */\r\n    Point.prototype.set = function (p) {\r\n        this.x = p.x;\r\n        this.y = p.y;\r\n        this.z = p.z;\r\n        this.w = p.w;\r\n        return this;\r\n    };\r\n    // Performs parameter-wise addition with the supplied `Point`. Excludes `this.w`.\r\n    Point.prototype.add = function (q) {\r\n        this.x += q.x;\r\n        this.y += q.y;\r\n        this.z += q.z;\r\n        return this;\r\n    };\r\n    // Performs parameter-wise subtraction with the supplied `Point`. Excludes `this.w`.\r\n    Point.prototype.subtract = function (q) {\r\n        this.x -= q.x;\r\n        this.y -= q.y;\r\n        this.z -= q.z;\r\n        return this;\r\n    };\r\n    // Apply a translation.  Excludes `this.w`.\r\n    Point.prototype.translate = function (x, y, z) {\r\n        this.x += x;\r\n        this.y += y;\r\n        this.z += z;\r\n        return this;\r\n    };\r\n    // Multiplies each parameters by the supplied scalar value. Excludes `this.w`.\r\n    Point.prototype.multiply = function (n) {\r\n        this.x *= n;\r\n        this.y *= n;\r\n        this.z *= n;\r\n        return this;\r\n    };\r\n    // Divides each parameters by the supplied scalar value. Excludes `this.w`.\r\n    Point.prototype.divide = function (n) {\r\n        this.x /= n;\r\n        this.y /= n;\r\n        this.z /= n;\r\n        return this;\r\n    };\r\n    // Rounds each coordinate to the nearest integer. Excludes `this.w`.\r\n    Point.prototype.round = function () {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        this.z = Math.round(this.z);\r\n        return this;\r\n    };\r\n    // Divides this `Point` by its magnitude. If the point is (0,0,0) we return (0,0,1).\r\n    Point.prototype.normalize = function () {\r\n        var n = this.magnitude();\r\n        if (n == 0) // Strict zero comparison -- may be worth using an epsilon\r\n            this.set(POINT_Z);\r\n        else\r\n            this.divide(n);\r\n        return this;\r\n    };\r\n    /** Returns a new point that is perpendicular to this point */\r\n    Point.prototype.perpendicular = function () {\r\n        var n = this.copy().cross(POINT_Z);\r\n        var mag = n.magnitude();\r\n        if (mag !== 0)\r\n            return n.divide(mag);\r\n        // can't find perpendicular of z axis, so use x axis\r\n        return this.copy().cross(POINT_X).normalize();\r\n    };\r\n    // Apply a transformation from the supplied `Matrix`.\r\n    Point.prototype.transform = function (matrix) {\r\n        var r = POINT_POOL;\r\n        r.x = this.x * matrix.m[0] + this.y * matrix.m[1] + this.z * matrix.m[2] + this.w * matrix.m[3];\r\n        r.y = this.x * matrix.m[4] + this.y * matrix.m[5] + this.z * matrix.m[6] + this.w * matrix.m[7];\r\n        r.z = this.x * matrix.m[8] + this.y * matrix.m[9] + this.z * matrix.m[10] + this.w * matrix.m[11];\r\n        r.w = this.x * matrix.m[12] + this.y * matrix.m[13] + this.z * matrix.m[14] + this.w * matrix.m[15];\r\n        this.set(r);\r\n        return (this);\r\n    };\r\n    // Returns this `Point`s magnitude squared. Excludes `this.w`.\r\n    Point.prototype.magnitudeSquared = function () {\r\n        return this.dot(this);\r\n    };\r\n    // Returns this `Point`s magnitude. Excludes `this.w`.\r\n    Point.prototype.magnitude = function () {\r\n        return Math.sqrt(this.magnitudeSquared());\r\n    };\r\n    // Computes the dot product with the supplied `Point`.\r\n    Point.prototype.dot = function (q) {\r\n        return this.x * q.x + this.y * q.y + this.z * q.z;\r\n    };\r\n    /** Computes the cross product with the supplied `Point`. */\r\n    Point.prototype.cross = function (q) {\r\n        var r = POINT_POOL;\r\n        r.x = this.y * q.z - this.z * q.y;\r\n        r.y = this.z * q.x - this.x * q.z;\r\n        r.z = this.x * q.y - this.y * q.x;\r\n        this.set(r);\r\n        return this;\r\n    };\r\n    return Point;\r\n}());\r\nexport { Point };\r\n// seen.Points = {\r\n//   X    : -> seen.P(1, 0, 0)\r\n//   Y    : -> seen.P(0, 1, 0)\r\n//   Z    : -> seen.P(0, 0, 1)\r\n//   ZERO : -> seen.P(0, 0, 0)\r\n// }\r\n// A pool object which prevents us from having to create new `Point` objects\r\n// for various calculations, which vastly improves performance.\r\nvar POINT_POOL = P(0, 0, 0, 0);\r\n// A few useful `Point` objects. Be sure that you don't invoke destructive\r\n// methods on these objects.\r\nexport var POINT_ZERO = P(0, 0, 0);\r\nexport var POINT_X = P(1, 0, 0);\r\nexport var POINT_Y = P(0, 1, 0);\r\nexport var POINT_Z = P(0, 0, 1);\r\n","// //// HTML5 Canvas Context\r\n// ------------------\r\n/** The very lowest-level commands for drawing on Canvas.\r\n  CanvasRenderContext and SVGRenderContext extend `RenderContext` for Canvas or SVG. */\r\nvar CanvasRenderContext /*extends RenderContext*/ = /** @class */ (function () {\r\n    function CanvasRenderContext(el) {\r\n        //super()\r\n        // console.log(el)\r\n        this.el = document.getElementById(el);\r\n        // console.log(this.el)\r\n        this.ctx = this.el.getContext('2d');\r\n        // console.log(this.ctx)\r\n    }\r\n    // layer (layer) {\r\n    //   this.layers.push {\r\n    //     layer   : layer\r\n    //     context : new seen.CanvasLayerRenderContext(this.ctx)\r\n    //   }\r\n    //   return this\r\n    // }\r\n    CanvasRenderContext.prototype.reset = function () {\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.clearRect(0, 0, this.el.width, this.el.height);\r\n    };\r\n    CanvasRenderContext.prototype.draw = function (style) {\r\n        // Copy over SVG CSS attributes\r\n        if (style.strokeStyle)\r\n            this.ctx.strokeStyle = style.strokeStyle;\r\n        // TODO: which do we need of the rest?  Can we deal with them as a class?\r\n        if (style.lineWidth)\r\n            this.ctx.lineWidth = style.lineWidth;\r\n        // if (style.textAnchor)\r\n        //     this.ctx.textAlign = style.textAnchor\r\n        this.ctx.stroke();\r\n        return this;\r\n    };\r\n    CanvasRenderContext.prototype.fill = function (style) {\r\n        // Copy over SVG CSS attributes\r\n        if (style.fillStyle)\r\n            this.ctx.fillStyle = style.fillStyle;\r\n        console.log('fillStyle', style.fillStyle);\r\n        // if (style['text-anchor'])\r\n        //     this.ctx.textAlign = style['text-anchor']\r\n        // if (style['fill-opacity'])\r\n        //     this.ctx.globalAlpha = style['fill-opacity']\r\n        this.ctx.fill();\r\n        return this;\r\n    };\r\n    /** Create a polygon path for a CANVAS rendering */\r\n    CanvasRenderContext.prototype.path = function (points) {\r\n        this.ctx.beginPath();\r\n        for (var i = 0, j = 0, len = points.length; j < len; i = ++j) {\r\n            var p = points[i];\r\n            // tom's kluge for now /////////////////////\r\n            // scale points by 10, and move them to 50,50\r\n            p.x = p.x * 10 + 50;\r\n            p.y = p.y * 10 + 50;\r\n            /////////////////////////////\r\n            if (i === 0) {\r\n                this.ctx.moveTo(p.x, p.y);\r\n                console.log('moveTo', p.x, p.y);\r\n            }\r\n            else {\r\n                this.ctx.lineTo(p.x, p.y);\r\n                console.log('lineTo', p.x, p.y);\r\n            }\r\n        }\r\n        this.ctx.closePath();\r\n        return this;\r\n    };\r\n    CanvasRenderContext.prototype.rect = function (width, height) {\r\n        this.ctx.rect(0, 0, width, height);\r\n        return this;\r\n    };\r\n    CanvasRenderContext.prototype.circle = function (center, radius) {\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, true);\r\n        return this;\r\n    };\r\n    CanvasRenderContext.prototype.fillText = function (m, text, style) {\r\n        this.ctx.save();\r\n        this.ctx.setTransform(m[0], m[3], -m[1], -m[4], m[2], m[5]);\r\n        if (style.font)\r\n            this.ctx.font = style.font;\r\n        if (style.fill)\r\n            this.ctx.fillStyle = style.fill;\r\n        // TODO: string is not assignable...\r\n        // if (style['text-anchor'])\r\n        //     this.ctx.textAlign = this._cssToCanvasAnchor(style['text-anchor'])\r\n        this.ctx.fillText(text, 0, 0);\r\n        this.ctx.restore();\r\n        return this;\r\n    };\r\n    CanvasRenderContext.prototype._cssToCanvasAnchor = function (anchor) {\r\n        if (anchor == 'middle')\r\n            return 'center';\r\n        return anchor;\r\n    };\r\n    return CanvasRenderContext;\r\n}());\r\nexport { CanvasRenderContext };\r\n// TODO: figure out whether we need these two...\r\n// class CanvasLayerRenderContext extends RenderLayerContext\r\n//   constructor  (this.ctx) {\r\n//     this.pathPainter  = new CanvasPathPainter(this.ctx)\r\n//     this.ciclePainter = new CanvasCirclePainter(this.ctx)\r\n//     this.textPainter  = new CanvasTextPainter(this.ctx)\r\n//     this.rectPainter  = new CanvasRectPainter(this.ctx)\r\n//   }\r\n//   path    () {this.pathPainter()}\r\n//   rect    () {this.rectPainter()}\r\n//   circle  () {this.ciclePainter()}\r\n//   text    () {this.textPainter()}\r\n// }\r\n// function CanvasContext (elementId, scene){\r\n//   let context = new CanvasRenderContext(elementId)\r\n//   if (scene) {\r\n//     context.sceneLayer(scene)\r\n//   }\r\n//   return context\r\n// }\r\n","import { P, POINT_ZERO } from '../point';\r\n// //// RenderModels\r\n// ------------------\r\nvar DEFAULT_NORMAL = P(0, 0, 1); // Z\r\n// The `RenderModel` object contains the transformed and projected points as\r\n// well as various data needed to shade and paint a `Surface`.\r\n//\r\n// Once initialized, the object will have a constant memory footprint down to\r\n// `Number` primitives. Also, we compare each transform and projection to\r\n// prevent unnecessary re-computation.\r\n//\r\n// If you need to force a re-computation, mark the surface as 'dirty'.\r\nvar RenderModel = /** @class */ (function () {\r\n    function RenderModel(surface, transform, projection, viewport) {\r\n        this.surface = surface;\r\n        this.points = this.surface.points;\r\n        // this.transformed = this._initRenderData()\r\n        // this.projected   = this._initRenderData()\r\n        this._update();\r\n    }\r\n    RenderModel.prototype.update = function (transform, projection, viewport) {\r\n        if (!this.surface.dirty\r\n            && transform.isEqual(this.transformed)\r\n            && projection.isEqual(this.projected)\r\n            && viewport.prescale.isEqual(this.viewport.prescale)) {\r\n            // do nothing\r\n        }\r\n        else {\r\n            this.transform = transform;\r\n            this.projection = projection;\r\n            this.viewport.prescale = viewport.prescale;\r\n            this.viewport.postscale = viewport.postscale;\r\n            this._update();\r\n        }\r\n    };\r\n    RenderModel.prototype._update = function () {\r\n        //   // Apply model transforms to surface points\r\n        //   this._math(this.transformed, this.points, this.transform, false)\r\n        //   // Project into camera space\r\n        //   let cameraSpace:Point[] = this.points.map(p => { p.copy().transform(this.projection.m)})\r\n        //   this.inFrustrum = this._checkFrustrum(cameraSpace)\r\n        //   // Project into screen space\r\n        //   this._math(this.projected, cameraSpace, this.viewport, true)\r\n        //   this.surface.dirty = false\r\n        console.log('renderModel._update()');\r\n    };\r\n    return RenderModel;\r\n}());\r\nexport { RenderModel };\r\n// The `LightRenderModel` stores pre-computed values necessary for shading\r\n// surfaces with the supplied `Light`.\r\nvar LightRenderModel = /** @class */ (function () {\r\n    function LightRenderModel(light, transform) {\r\n        this.colorIntensity = light.color.copy().scale(light.intensity);\r\n        this.type = light.type;\r\n        this.intensity = light.intensity;\r\n        this.point = light.point.copy().transform(transform);\r\n        this.origin = POINT_ZERO.transform(transform);\r\n        this.normal = light.normal.copy().transform(transform).subtract(this.origin).normalize();\r\n    }\r\n    return LightRenderModel;\r\n}());\r\n","// //// Scene\r\nimport { Model } from './model';\r\nimport { Camera, Viewport } from './camera';\r\nimport { RenderModel } from './render/rendermodel';\r\nimport { NullShape } from './shapes/primitives';\r\n/** A `Scene` is the main object for a view of a scene. */\r\nvar Scene = /** @class */ (function () {\r\n    function Scene(options) {\r\n        // The root model for the scene, which contains `Shape`s and\r\n        // other `Model`s (Models are hierarchical).  \r\n        this.model = new Model(NullShape());\r\n        // The `Camera`, which defines the projection transformation. The default\r\n        // projection is perspective.\r\n        this.camera = new Camera();\r\n        // The `Viewport`, which defines the projection from shape-space to\r\n        // projection-space then to screen-space. The default viewport is on a\r\n        // space from (0,0,0) to (1,1,1). To map more naturally to pixels, create a\r\n        // viewport with the same width/height as the DOM element.\r\n        this.viewport = new Viewport().origin(1, 1);\r\n        // The scene's shader determines which lighting model is used.\r\n        // TODO: add this back\r\n        // public shader = new Shaders()\r\n        // The `cullBackfaces` boolean can be used to turn off backface-culling\r\n        // for the whole scene. Beware, turning this off can slow down a scene's\r\n        // rendering by a factor of 2. You can also turn off backface-culling for\r\n        // individual surfaces with a boolean on those objects.\r\n        this.cullBackfaces = true;\r\n        // The `fractionalPoints` boolean determines if we round the surface\r\n        // coordinates to the nearest integer. Rounding the coordinates before\r\n        // display speeds up path drawing  especially when using an SVG context\r\n        // since it cuts down on the length of path data. Anecdotally, my speedup\r\n        // on a complex demo scene was 10 FPS. However, it does introduce a slight\r\n        // jittering effect when animating.\r\n        this.fractionalPoints = false;\r\n        // The `cache` boolean (default : true) enables a simple cache for\r\n        // renderModels, which are generated for each surface in the scene. The\r\n        // cache is a simple Object keyed by the surface's unique id. The cache has\r\n        // no eviction policy. To flush the cache, call `.flushCache()`\r\n        this.cache = true;\r\n        //Util.defaults(this, options, this.defaults())\r\n        this._renderModelCache = {};\r\n    }\r\n    // The primary method that produces the render models, which are then used\r\n    // by the `RenderContext` to paint the scene.\r\n    Scene.prototype.render = function () {\r\n        // Compute the projection matrix including the viewport and camera\r\n        // transformation matrices.\r\n        // \r\n        var projection = this.camera\r\n            .m\r\n            .multiply(this.viewport.prescale);\r\n        // TODO  .multiply(this.camera.projection)\r\n        var transform = this.model.m;\r\n        // TODO: ??? what is this?\r\n        // this.viewport   = this.viewport.postscale\r\n        var renderModels = [];\r\n        // Compute transformed and projected geometry.\r\n        var results = [];\r\n        for (var i = 0, len = this.model.surfaces.length; i < len; i++) {\r\n            var surface = this.model.surfaces[i];\r\n            var renderModel = this._renderSurface(surface, transform, projection, this.viewport);\r\n            // Test projected normal's z-coordinate for culling (if enabled).\r\n            // if ((!_this.cullBackfaces || !surface.cullBackfaces || renderModel.projected.normal.z < 0) && renderModel.inFrustrum) {\r\n            //   renderModel.fill = (ref1 = surface.fillMaterial) != null ? ref1.render(lights, _this.shader, renderModel.transformed) : void 0;\r\n            //   renderModel.stroke = (ref2 = surface.strokeMaterial) != null ? ref2.render(lights, _this.shader, renderModel.transformed) : void 0;\r\n            //   // Round coordinates (if enabled)\r\n            //   if (_this.fractionalPoints !== true) {\r\n            //     ref3 = renderModel.projected.points;\r\n            //     for (j = 0, len1 = ref3.length; j < len1; j++) {\r\n            //       p = ref3[j];\r\n            //       p.round();\r\n            //     }\r\n            //   }\r\n            //   results.push(renderModels.push(renderModel));\r\n            // } else {\r\n            results.push(void 0);\r\n            //}\r\n        }\r\n    };\r\n    // this.model.eachRenderable(function(light, transform) {\r\n    //     // Compute light model data.\r\n    //     return new seen.LightRenderModel(light, transform);\r\n    // }, (function(_this) {\r\n    //   return function(shape, lights, transform) {\r\n    //     var i, j, len, len1, p, ref, ref1, ref2, ref3, renderModel, results, surface;\r\n    //       // Compute transformed and projected geometry.\r\n    //       ref = shape.surfaces;\r\n    //     results = [];\r\n    //     for (i = 0, len = ref.length; i < len; i++) {\r\n    //       surface = ref[i];\r\n    //       renderModel = _this._renderSurface(surface, transform, projection, viewport);\r\n    //       // Test projected normal's z-coordinate for culling (if enabled).\r\n    //       if ((!_this.cullBackfaces || !surface.cullBackfaces || renderModel.projected.normal.z < 0) && renderModel.inFrustrum) {\r\n    //         renderModel.fill = (ref1 = surface.fillMaterial) != null ? ref1.render(lights, _this.shader, renderModel.transformed) : void 0;\r\n    //         renderModel.stroke = (ref2 = surface.strokeMaterial) != null ? ref2.render(lights, _this.shader, renderModel.transformed) : void 0;\r\n    //         // Round coordinates (if enabled)\r\n    //         if (_this.fractionalPoints !== true) {\r\n    //           ref3 = renderModel.projected.points;\r\n    //           for (j = 0, len1 = ref3.length; j < len1; j++) {\r\n    //             p = ref3[j];\r\n    //             p.round();\r\n    //           }\r\n    //         }\r\n    //         results.push(renderModels.push(renderModel));\r\n    //       } else {\r\n    //         results.push(void 0);\r\n    //       }\r\n    //     }\r\n    //     return results;\r\n    //   };\r\n    // })(this));\r\n    /** Sort render models by projected z coordinate. This ensures that the surfaces\r\n     farthest from the eye are painted first. (Painter's Algorithm) */\r\n    Scene.prototype.renderModels = function (a, b) {\r\n        return b.projected.barycenter.z - a.projected.barycenter.z;\r\n    };\r\n    /** Get or create the rendermodel for the given surface.\r\n        If `this.cache` is true, we cache these models to reduce object creation and recomputation. */\r\n    Scene.prototype._renderSurface = function (surface, transform, projection, viewport) {\r\n        if (!this.cache)\r\n            return new RenderModel(surface, transform, projection, viewport);\r\n        var renderModel = this._renderModelCache[surface.id];\r\n        if (!renderModel) //was existential operator\r\n            renderModel = this._renderModelCache[surface.id] = new RenderModel(surface, transform, projection, viewport);\r\n        else\r\n            renderModel.update(transform, projection, viewport);\r\n        return renderModel;\r\n    };\r\n    /** Removes all elements from the cache. This may be necessary if you add and\r\n     remove many shapes from the scene's models since this cache has no eviction policy. */\r\n    Scene.prototype.flushCache = function () {\r\n        this._renderModelCache = {};\r\n    };\r\n    return Scene;\r\n}());\r\nexport { Scene };\r\n","//// Shapes\r\n// //////// Shape primitives and shape-making methods\r\n// ------------------\r\nimport { P } from '../point';\r\nimport { Shape, Surface } from '../surface'; // TODO: rename Shape to Surface, Surface to Triangle\r\n// Map to points in the surfaces of a tetrahedron\r\nvar TETRAHEDRON_COORDINATE_MAP = [\r\n    [0, 2, 1],\r\n    [0, 1, 3],\r\n    [3, 2, 0],\r\n    [1, 2, 3],\r\n];\r\n// triangles formed from points in TETRAHEDRON_COORDINATE_MAP\r\nvar TETRA_MAP = [\r\n    [0, 1, 2],\r\n    [0, 2, 3],\r\n    [0, 1, 3],\r\n    [1, 2, 3],\r\n];\r\n// Map to points in the surfaces of a cube\r\nvar CUBE_COORDINATE_MAP = [\r\n    [0, 1, 3, 2],\r\n    [5, 4, 6, 7],\r\n    [1, 0, 4, 5],\r\n    [2, 3, 7, 6],\r\n    [3, 1, 5, 7],\r\n    [0, 2, 6, 4],\r\n];\r\n// Map to points in the surfaces of a rectangular pyramid\r\nvar PYRAMID_COORDINATE_MAP = [\r\n    [1, 0, 2, 3],\r\n    [0, 1, 4],\r\n    [2, 0, 4],\r\n    [3, 2, 4],\r\n    [1, 3, 4],\r\n];\r\n// Altitude of eqiulateral triangle for computing triangular patch size\r\nvar EQUILATERAL_TRIANGLE_ALTITUDE = Math.sqrt(3.0) / 2.0;\r\n// Points array of an icosahedron\r\nvar ICOS_X = 0.525731112119133606;\r\nvar ICOS_Z = 0.850650808352039932;\r\nvar ICOSAHEDRON_POINTS = [\r\n    P(-ICOS_X, 0.0, -ICOS_Z),\r\n    P(ICOS_X, 0.0, -ICOS_Z),\r\n    P(-ICOS_X, 0.0, ICOS_Z),\r\n    P(ICOS_X, 0.0, ICOS_Z),\r\n    P(0.0, ICOS_Z, -ICOS_X),\r\n    P(0.0, ICOS_Z, ICOS_X),\r\n    P(0.0, -ICOS_Z, -ICOS_X),\r\n    P(0.0, -ICOS_Z, ICOS_X),\r\n    P(ICOS_Z, ICOS_X, 0.0),\r\n    P(-ICOS_Z, ICOS_X, 0.0),\r\n    P(ICOS_Z, -ICOS_X, 0.0),\r\n    P(-ICOS_Z, -ICOS_X, 0.0),\r\n];\r\n// Map to points in the surfaces of an icosahedron\r\nvar ICOSAHEDRON_COORDINATE_MAP = [\r\n    [0, 4, 1],\r\n    [0, 9, 4],\r\n    [9, 5, 4],\r\n    [4, 5, 8],\r\n    [4, 8, 1],\r\n    [8, 10, 1],\r\n    [8, 3, 10],\r\n    [5, 3, 8],\r\n    [5, 2, 3],\r\n    [2, 7, 3],\r\n    [7, 10, 3],\r\n    [7, 6, 10],\r\n    [7, 11, 6],\r\n    [11, 0, 6],\r\n    [0, 1, 6],\r\n    [6, 1, 10],\r\n    [9, 0, 11],\r\n    [9, 11, 2],\r\n    [9, 2, 5],\r\n    [7, 2, 11],\r\n];\r\n// TODO: Shapes should be part of the Shape() class  - box:Shape = new Shape().box()\r\n/** static methods to create `Shape` */\r\nvar Triangle = /** @class */ (function () {\r\n    function Triangle() {\r\n    }\r\n    return Triangle;\r\n}());\r\nexport { Triangle };\r\nvar Primitive = /** @class */ (function () {\r\n    function Primitive() {\r\n        this.triangles = [];\r\n    }\r\n    return Primitive;\r\n}());\r\nexport { Primitive };\r\n/** Sometimes we just want an empty `Model` that we can add children to */\r\nexport function NullShape() {\r\n    var points = [P(0, 0, 0), P(0, 0, 0), P(0, 0, 0)];\r\n    return new Shape('nullshape', mapPointsToSurfaces(points, []));\r\n}\r\nexport function Cube() {\r\n    var points = [P(-1, -1, -1), P(-1, -1, 1), P(-1, 1, -1), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];\r\n    return new Shape('cube', mapPointsToSurfaces(points, CUBE_COORDINATE_MAP));\r\n}\r\n//   unitcube() {\r\n//   let points = [P(0, 0, 0), P(0, 0, 1), P(0, 1, 0), P(0, 1, 1), P(1, 0, 0), P(1, 0, 1), P(1, 1, 0), P(1, 1, 1)];\r\n//   return new Shape('unitcube', this.mapPointsToSurfaces( points, CUBE_COORDINATE_MAP ));\r\n// }\r\n//   rectangle: (function (_this) {\r\n//     return function (point1, point2) {\r\n//       var compose, points;\r\n//       compose = function (x, y, z) {\r\n//         return P(x(point1.x, point2.x), y(point1.y, point2.y), z(point1.z, point2.z));\r\n//       };\r\n//       points = [compose(Math.min, Math.min, Math.min), compose(Math.min, Math.min, Math.max), compose(Math.min, Math.max, Math.min), compose(Math.min, Math.max, Math.max), compose(Math.max, Math.min, Math.min), compose(Math.max, Math.min, Math.max), compose(Math.max, Math.max, Math.min), compose(Math.max, Math.max, Math.max)];\r\n//       return new Shape('rect', Shapes.mapPointsToSurfaces(points, CUBE_COORDINATE_MAP));\r\n//     };\r\n//   })(this),\r\nexport function pyramid() {\r\n    var points = [P(0, 0, 0), P(0, 0, 1), P(1, 0, 0), P(1, 0, 1), P(0.5, 1, 0.5)];\r\n    return new Shape('pyramid', mapPointsToSurfaces(points, PYRAMID_COORDINATE_MAP));\r\n}\r\n//   tetrahedron: (function (_this) {\r\n//     return function () {\r\n//       var points;\r\n//       points = [P(1, 1, 1), P(-1, -1, 1), P(-1, 1, -1), P(1, -1, -1)];\r\n//       return new Shape('tetrahedron', Shapes.mapPointsToSurfaces(points, TETRAHEDRON_COORDINATE_MAP));\r\n//     };\r\n//   })(this),\r\n//   icosahedron: function () {\r\n//     return new Shape('icosahedron', Shapes.mapPointsToSurfaces(ICOSAHEDRON_POINTS, ICOSAHEDRON_COORDINATE_MAP));\r\n//   },\r\n//   sphere: function (subdivisions) {\r\n//     var i, j, ref, triangles;\r\n//     if (subdivisions == null) {\r\n//       subdivisions = 2;\r\n//     }\r\n//     triangles = ICOSAHEDRON_COORDINATE_MAP.map(function (coords) {\r\n//       return coords.map(function (c) {\r\n//         return ICOSAHEDRON_POINTS[c];\r\n//       });\r\n//     });\r\n//     for (i = j = 0, ref = subdivisions; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\r\n//       triangles = Shapes._subdivideTriangles(triangles);\r\n//     }\r\n//     return new Shape('sphere', triangles.map(function (triangle) {\r\n//       return new Surface(triangle.map(function (v) {\r\n//         return v.copy();\r\n//       }));\r\n//     }));\r\n//   },\r\n//   pipe: function (point1, point2, radius, segments) {\r\n//     var axis, j, perp, points, quat, results, theta;\r\n//     if (radius == null) {\r\n//       radius = 1;\r\n//     }\r\n//     if (segments == null) {\r\n//       segments = 8;\r\n//     }\r\n//     axis = point2.copy().subtract(point1);\r\n//     perp = axis.perpendicular().multiply(radius);\r\n//     theta = -Math.PI * 2.0 / segments;\r\n//     quat = Quaternion.pointAngle(axis.copy().normalize(), theta).toMatrix();\r\n//     points = (function () {\r\n//       results = [];\r\n//       for (var j = 0; 0 <= segments ? j < segments : j > segments; 0 <= segments ? j++ : j--) { results.push(j); }\r\n//       return results;\r\n//     }).apply(this).map(function (i) {\r\n//       var p;\r\n//       p = point1.copy().add(perp);\r\n//       perp.transform(quat);\r\n//       return p;\r\n//     });\r\n//     return Shapes.extrude(points, axis);\r\n//   },\r\n//   patch: function (nx, ny) {\r\n//     var column, j, k, l, len1, len2, len3, m, n, p, pts, pts0, pts1, ref, ref1, ref2, ref3, surfaces, x, y;\r\n//     if (nx == null) {\r\n//       nx = 20;\r\n//     }\r\n//     if (ny == null) {\r\n//       ny = 20;\r\n//     }\r\n//     nx = Math.round(nx);\r\n//     ny = Math.round(ny);\r\n//     surfaces = [];\r\n//     for (x = j = 0, ref = nx; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {\r\n//       column = [];\r\n//       for (y = k = 0, ref1 = ny; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {\r\n//         pts0 = [P(x, y), P(x + 1, y - 0.5), P(x + 1, y + 0.5)];\r\n//         pts1 = [P(x, y), P(x + 1, y + 0.5), P(x, y + 1)];\r\n//         ref2 = [pts0, pts1];\r\n//         for (l = 0, len1 = ref2.length; l < len1; l++) {\r\n//           pts = ref2[l];\r\n//           for (m = 0, len2 = pts.length; m < len2; m++) {\r\n//             p = pts[m];\r\n//             p.x *= EQUILATERAL_TRIANGLE_ALTITUDE;\r\n//             p.y += x % 2 === 0 ? 0.5 : 0;\r\n//           }\r\n//           column.push(pts);\r\n//         }\r\n//       }\r\n//       if (x % 2 !== 0) {\r\n//         ref3 = column[0];\r\n//         for (n = 0, len3 = ref3.length; n < len3; n++) {\r\n//           p = ref3[n];\r\n//           p.y += ny;\r\n//         }\r\n//         column.push(column.shift());\r\n//       }\r\n//       surfaces = surfaces.concat(column);\r\n//     }\r\n//     return new Shape('patch', surfaces.map(function (s) {\r\n//       return new Surface(s);\r\n//     }));\r\n//   },\r\n//   text: function (text, surfaceOptions) {\r\n//     var key, surface, val;\r\n//     if (surfaceOptions == null) {\r\n//       surfaceOptions = {};\r\n//     }\r\n//     surface = new Surface(Affine.ORTHONORMAL_BASIS(), Painters.text);\r\n//     surface.text = text;\r\n//     for (key in surfaceOptions) {\r\n//       val = surfaceOptions[key];\r\n//       surface[key] = val;\r\n//     }\r\n//     return new Shape('text', [surface]);\r\n//   },\r\n//   extrude: function (points, offset) {\r\n//     var back, front, i, j, len, p, ref, surfaces;\r\n//     surfaces = [];\r\n//     front = new Surface((function () {\r\n//       var j, len1, results;\r\n//       results = [];\r\n//       for (j = 0, len1 = points.length; j < len1; j++) {\r\n//         p = points[j];\r\n//         results.push(p.copy());\r\n//       }\r\n//       return results;\r\n//     })());\r\n//     back = new Surface((function () {\r\n//       var j, len1, results;\r\n//       results = [];\r\n//       for (j = 0, len1 = points.length; j < len1; j++) {\r\n//         p = points[j];\r\n//         results.push(p.add(offset));\r\n//       }\r\n//       return results;\r\n//     })());\r\n//     for (i = j = 1, ref = points.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\r\n//       surfaces.push(new Surface([front.points[i - 1].copy(), back.points[i - 1].copy(), back.points[i].copy(), front.points[i].copy()]));\r\n//     }\r\n//     len = points.length;\r\n//     surfaces.push(new Surface([front.points[len - 1].copy(), back.points[len - 1].copy(), back.points[0].copy(), front.points[0].copy()]));\r\n//     back.points.reverse();\r\n//     surfaces.push(front);\r\n//     surfaces.push(back);\r\n//     return new Shape('extrusion', surfaces);\r\n//   },\r\n//   arrow: function (thickness, tailLength, tailWidth, headLength, headPointiness) {\r\n//     var htw, points;\r\n//     if (thickness == null) {\r\n//       thickness = 1;\r\n//     }\r\n//     if (tailLength == null) {\r\n//       tailLength = 1;\r\n//     }\r\n//     if (tailWidth == null) {\r\n//       tailWidth = 1;\r\n//     }\r\n//     if (headLength == null) {\r\n//       headLength = 1;\r\n//     }\r\n//     if (headPointiness == null) {\r\n//       headPointiness = 0;\r\n//     }\r\n//     htw = tailWidth / 2;\r\n//     points = [P(0, 0, 0), P(headLength + headPointiness, 1, 0), P(headLength, htw, 0), P(headLength + tailLength, htw, 0), P(headLength + tailLength, -htw, 0), P(headLength, -htw, 0), P(headLength + headPointiness, -1, 0)];\r\n//     return Shapes.extrude(points, P(0, 0, thickness));\r\n//   },\r\n//   path: function (points) {\r\n//     return new Shape('path', [new Surface(points)]);\r\n//   },\r\n//   custom: function (s) {\r\n//     var f, j, len1, p, ref, surfaces;\r\n//     surfaces = [];\r\n//     ref = s.surfaces;\r\n//     for (j = 0, len1 = ref.length; j < len1; j++) {\r\n//       f = ref[j];\r\n//       surfaces.push(new Surface((function () {\r\n//         var k, len2, results;\r\n//         results = [];\r\n//         for (k = 0, len2 = f.length; k < len2; k++) {\r\n//           p = f[k];\r\n//           results.push(P.apply(seen, p));\r\n//         }\r\n//         return results;\r\n//       })()));\r\n//     }\r\n//     return new Shape('custom', surfaces);\r\n//   },\r\n/** points[] are the vertexes of the shape (indexed from zero),\r\n * coordinateMap[] are sets of vertex indexes that form exterior triangles or quads\r\n * we return an array of `Surface` objects (triangles) ready to transform  */\r\nfunction mapPointsToSurfaces(points, coordinateMap) {\r\n    // TODO: convert all exterior quads to triangles  (eg: two triangles per side for a cube)\r\n    var s = [];\r\n    coordinateMap.forEach(function (element) {\r\n        // \r\n        s.push(new Surface(points[element[0]], points[element[1]], points[element[2]]));\r\n    });\r\n    return s;\r\n}\r\n//   _subdivideTriangles: function (triangles) {\r\n//     var j, len1, newTriangles, tri, v01, v12, v20;\r\n//     newTriangles = [];\r\n//     for (j = 0, len1 = triangles.length; j < len1; j++) {\r\n//       tri = triangles[j];\r\n//       v01 = tri[0].copy().add(tri[1]).normalize();\r\n//       v12 = tri[1].copy().add(tri[2]).normalize();\r\n//       v20 = tri[2].copy().add(tri[0]).normalize();\r\n//       newTriangles.push([tri[0], v01, v20]);\r\n//       newTriangles.push([tri[1], v12, v01]);\r\n//       newTriangles.push([tri[2], v20, v12]);\r\n//       newTriangles.push([v01, v12, v20]);\r\n//     }\r\n//     return newTriangles;\r\n//   }\r\n// };\r\n","// //// Surfaces and Shapes\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Util } from './util';\r\nimport { Material } from './materials';\r\nimport { Transformable } from './transformable';\r\n// A `Surface` is a defined as a planar object in 3D space. These paths don't\r\n// necessarily need to be convex, but they should be non-degenerate. This\r\n// library does not support shapes with holes.\r\n// TODO: rename 'Surface' to 'Triangle' and fix up the code\r\nvar Surface = /** @class */ (function (_super) {\r\n    __extends(Surface, _super);\r\n    function Surface(p1, p2, p3) {\r\n        var _this = _super.call(this) || this;\r\n        // When 'false' this will override backface culling, which is useful if your\r\n        // material is transparent. See comment in `Scene`.\r\n        _this.cullBackfaces = true;\r\n        // Fill and stroke may be `Material` objects, which define the color and\r\n        // finish of the object and are rendered using the scene's shader.\r\n        _this.fillMaterial = new Material('gray');\r\n        _this.strokeMaterial = null;\r\n        _this.dirty = false;\r\n        _this.triangle = [p1, p2, p3];\r\n        // We store a unique id for every surface so we can look them up quickly\r\n        // with the `renderModel` cache.\r\n        _this.id = 's' + Util.uniqueId();\r\n        return _this;\r\n        //this.painter = painter\r\n    }\r\n    Surface.prototype.fill = function (fill) {\r\n        this.fillMaterial = new Material('gray').create(fill);\r\n        return this;\r\n    };\r\n    Surface.prototype.stroke = function (stroke) {\r\n        this.strokeMaterial = new Material('gray').create(stroke);\r\n        return this;\r\n    };\r\n    return Surface;\r\n}(Transformable));\r\nexport { Surface };\r\n// A `Shape` contains a collection of surface. They may create a closed 3D\r\n// shape, but not necessarily. For example, a cube is a closed shape, but a\r\n// patch is not.\r\nvar Shape = /** @class */ (function (_super) {\r\n    __extends(Shape, _super);\r\n    function Shape(type, surfaces) {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = type;\r\n        _this.surfaces = surfaces;\r\n        return _this;\r\n    }\r\n    /** Apply the supplied fill `Material` to each surface */\r\n    Shape.prototype.fill = function (fill) {\r\n        //    this.eachSurface (s) => { s.fill(fill)}\r\n        return this;\r\n    };\r\n    /** Apply the supplied stroke `Material` to each surface */\r\n    Shape.prototype.stroke = function (stroke) {\r\n        //    this.eachSurface (s) -> s.stroke(stroke)\r\n        return this;\r\n    };\r\n    return Shape;\r\n}(Transformable));\r\nexport { Shape };\r\n","// `Transformable` base class extended by `Shape` and `Model`.\r\n//\r\n// It stores transformations in the scene. These include:\r\n// (1) Camera Projection and Viewport transformations.\r\n// (2) Transformations of any `Transformable` type object\r\n//\r\n// Underneath, it's just matrix arithmetic.  When you use\r\n// a matrix object in this library, they are really\r\n// instances of 'Transformable'\r\n// A convenience method for constructing Matrix objects.\r\nexport function M(m) {\r\n    console.assert(m.length === 16, 'array for M() was not length 16');\r\n    return (new Matrix(m));\r\n}\r\n// Most of the matrix methods are destructive, so be sure to use `.copy()`\r\n// when you want to preserve an object's value.\r\n// All `Transformable` objects get matrix-transformation methods like\r\n//  'scale', 'translate', 'rotx', 'roty', 'rotz', 'matrix', 'reset', 'bake'\r\n//\r\n// The advantages of keeping transforms in `Matrix` form are\r\n// (1) lazy computation of point position\r\n// (2) ability combine hierarchical transformations easily\r\n// (3) ability to reset transformations to an original state.\r\n//\r\n// Resetting transformations is especially useful when you want to animate\r\n// interpolated values. Instead of computing the difference at each animation\r\n// step, you can compute the global interpolated value for that time step and\r\n// apply that value directly to a matrix (once it is reset).\r\nvar IDENTITY = [1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1];\r\n// Models and Shapes are decendents of 'transformable', a single matrix\r\n// determines their scale, rotation, and translation     \r\n// Cameras and Lights are also transformables, but this doesn't totally make \r\n// sense since they can't be scaled.\r\nvar Transformable = /** @class */ (function () {\r\n    function Transformable() {\r\n        this.m = new Matrix(IDENTITY); // shallow copy\r\n    }\r\n    Transformable.prototype.isEqual = function (other) {\r\n        return this.m.isEqual(other.m);\r\n    };\r\n    return Transformable;\r\n}());\r\nexport { Transformable };\r\nvar Matrix = /** @class */ (function () {\r\n    /** Accepts a 16-value `Array`, defaults to the identity matrix.*/\r\n    function Matrix(m) {\r\n        this.m = Array.from(IDENTITY);\r\n        this.ARRAY_POOL = Array.from(IDENTITY);\r\n        this.baked = Array.from(IDENTITY);\r\n        if (m)\r\n            this.m = m;\r\n    }\r\n    ///////////////////////////////////////////////\r\n    // here is the method that does all the work !!\r\n    ///////////////////////////////////////////////\r\n    // Apply a transformation`\r\n    Matrix.prototype.transform = function (m) {\r\n        this.multiply(m);\r\n        return this;\r\n    };\r\n    ///////////////////////////////////////////////\r\n    // rest of the class is just matrix arithmetic\r\n    ///////////////////////////////////////////////\r\n    // Returns a new matrix instances with a copy of the value array\r\n    Matrix.prototype.copy = function () {\r\n        return new Matrix(Array.from(this.m));\r\n    };\r\n    // Multiply by the 16-value `Array` argument. This method uses the\r\n    // `ARRAY_POOL`, which prevents us from having to re-initialize a new\r\n    // temporary matrix every time. This drastically improves performance.\r\n    Matrix.prototype.multiply = function (m) {\r\n        if (!Array.isArray(m)) // will fail anyhow, but want a stack trace\r\n            console.trace('transformable multiply');\r\n        var c = this.ARRAY_POOL; // just a reference pointer\r\n        for (var j = 0; j < 4; j++) {\r\n            for (var i = 0; i < 16; i += 4) {\r\n                c[i + j] =\r\n                    m.m[i] * this.m[j] +\r\n                        m.m[i + 1] * this.m[4 + j] +\r\n                        m.m[i + 2] * this.m[8 + j] +\r\n                        m.m[i + 3] * this.m[12 + j];\r\n            }\r\n        }\r\n        this.ARRAY_POOL = this.m; // just a reference pointer\r\n        this.m = c;\r\n        return this;\r\n    };\r\n    // Resets the matrix to the baked-in (default: identity).\r\n    Matrix.prototype.reset = function () {\r\n        this.m = Array.from(this.baked); // shallow copy\r\n        return this;\r\n    };\r\n    // Sets the array that this matrix will return to when calling `.reset()`.\r\n    // With no arguments, it uses the current matrix state.\r\n    Matrix.prototype.bake = function (m) {\r\n        if (m)\r\n            this.baked = m;\r\n        else\r\n            this.baked = Array.from(this.m);\r\n        return this;\r\n    };\r\n    //   // Multiply by the `Matrix` argument.\r\n    //   multiply(b: matrix) {\r\n    //       return this.matrix(b.m)\r\n    //   }\r\n    //   // Tranposes this matrix\r\n    //   transpose() {\r\n    //       let c = this.ARRAY_POOL;\r\n    //       let i, k, len, ti;\r\n    //       for (i = k = 0, len = TRANSPOSE_INDICES.length; k < len; i = k++) {\r\n    //           ti = TRANSPOSE_INDICES[i];\r\n    //           c[i] = this.m[ti];\r\n    //       }\r\n    //       ARRAY_POOL = this.m;\r\n    //       this.m = c;\r\n    //       return this;\r\n    //   }\r\n    // Apply a rotation about the X axis. `Theta` is measured in Radians\r\n    Matrix.prototype.rotx = function (theta) {\r\n        var ct = Math.cos(theta);\r\n        var st = Math.sin(theta);\r\n        var rm = [1, 0, 0, 0, 0, ct, -st, 0, 0, st, ct, 0, 0, 0, 0, 1];\r\n        return M(rm);\r\n    };\r\n    // Apply a rotation about the Y axis. `Theta` is measured in Radians\r\n    Matrix.prototype.roty = function (theta) {\r\n        var ct = Math.cos(theta);\r\n        var st = Math.sin(theta);\r\n        var rm = [ct, 0, st, 0, 0, 1, 0, 0, -st, 0, ct, 0, 0, 0, 0, 1];\r\n        return M(rm);\r\n    };\r\n    // Apply a rotation about the Z axis. `Theta` is measured in Radians\r\n    Matrix.prototype.rotz = function (theta) {\r\n        var ct = Math.cos(theta);\r\n        var st = Math.sin(theta);\r\n        var rm = [ct, -st, 0, 0, st, ct, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n        return M(rm);\r\n    };\r\n    // Apply a translation. All arguments default to `0`\r\n    Matrix.prototype.translate = function (x, y, z) {\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        if (z === void 0) { z = 0; }\r\n        var rm = [1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1];\r\n        return M(rm);\r\n    };\r\n    // Apply a scale. If not all arguments are supplied, each dimension (x,y,z)\r\n    // is copied from the previous arugment. Therefore, `_scale()` is equivalent\r\n    // to `_scale(1,1,1)`, and `_scale(1,-1)` is equivalent to `_scale(1,-1,-1)`\r\n    Matrix.prototype.scale = function (sx, sy, sz) {\r\n        if (sx === void 0) { sx = 1; }\r\n        if (!sy)\r\n            sy = sx;\r\n        if (!sz)\r\n            sz = sy;\r\n        var rm = [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1];\r\n        return M(rm);\r\n    };\r\n    // Returns `true` iff the supplied `Arrays` are the same size and contain the same values.\r\n    Matrix.prototype.isEqual = function (other) {\r\n        var i, j, len, val;\r\n        // if (this.matrix.length !== other.length) {\r\n        //    return false;\r\n        // }\r\n        for (i = 0, len = 16; i < len; i++) {\r\n            if (this.m[i] !== other.m[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return Matrix;\r\n}());\r\nexport { Matrix };\r\n//   identity() {\r\n//       return (new Transformable())\r\n//   }\r\n//   flipx() {\r\n//       return (this.identity().scale(-1, 1, 1))\r\n//   }\r\n//   flipy() {\r\n//       return (this.identity().scale(1, -1, 1))\r\n//   }\r\n//   flipz() {\r\n//       return (this.identity().scale(1, 1, -1))\r\n//   }\r\n","// //// Util\r\n// //////// Utility methods\r\n// ------------------\r\nvar NEXT_UNIQUE_ID = 1; // An auto-incremented value\r\nvar Util = /** @class */ (function () {\r\n    function Util() {\r\n    }\r\n    // Copies default values. First, overwrite undefined attributes of `obj` from\r\n    // `opts`. Second, overwrite undefined attributes of `obj` from `defaults`.\r\n    Util.defaults = function (obj, opts, defaults) {\r\n        var prop, results;\r\n        for (prop in opts) {\r\n            if (obj[prop] == null) {\r\n                obj[prop] = opts[prop];\r\n            }\r\n        }\r\n        results = [];\r\n        for (prop in defaults) {\r\n            if (obj[prop] == null) {\r\n                results.push(obj[prop] = defaults[prop]);\r\n            }\r\n            else {\r\n                results.push(void 0);\r\n            }\r\n        }\r\n        return results;\r\n    };\r\n    /** Returns an ID which is unique to this instance of the library */ // TODO: change to type 'symbol'?\r\n    Util.uniqueId = function (prefix) {\r\n        if (prefix === void 0) { prefix = 'x'; }\r\n        return (prefix + NEXT_UNIQUE_ID++);\r\n    };\r\n    // Accept a DOM element or a string. If a string is provided, we assume it is\r\n    // the id of an element, which we return.\r\n    Util.element = function (elementOrString) {\r\n        if (typeof elementOrString === 'string') {\r\n            return document.getElementById(elementOrString);\r\n        }\r\n        else {\r\n            return elementOrString;\r\n        }\r\n    };\r\n    return Util;\r\n}());\r\nexport { Util };\r\n"],"sourceRoot":""}