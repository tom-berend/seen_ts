{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./demo.ts","webpack:///./src/Seen2.ts","webpack:///./src/camera.ts","webpack:///./src/canvas.ts","webpack:///./src/color.ts","webpack:///./src/light.ts","webpack:///./src/materials.ts","webpack:///./src/model.ts","webpack:///./src/paon.ts","webpack:///./src/point.ts","webpack:///./src/scene.ts","webpack:///./src/shaders.ts","webpack:///./src/shape.ts","webpack:///./src/shapes/primitives.ts","webpack:///./src/surface.ts","webpack:///./src/transformable.ts","webpack:///./src/util.ts","webpack:///./src/vectorMath.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACE;AACtC,UAAU,EAAE;AACwD;AAC9B;AACF;AACpC;AACA;AACA,cAAc,kDAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAK,gBAAgB;AACrC,8BAA8B,kBAAkB;AAChD,wBAAwB,kBAAkB;AAC1C,cAAc,kEAAW,EAAE,kBAAkB;AAC7C,+BAA+B,kBAAkB;AACjD,aAAa,mEAAY;AACzB;AACA;AACA,gBAAgB,kDAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gDAAK;AAChD,2CAA2C,gDAAK;AAChD,2CAA2C,gDAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,wCAAwC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;;;;;;;;;;;AClGJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,cAAc,cAAc;AACI;AACA;AACgB;AACZ;AACJ;AACJ;;;;;;;;;;;;;ACT5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACkD;AACb;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,+BAA+B,WAAW;AAC1C,gCAAgC,aAAa;AAC7C,6BAA6B,SAAS;AACtC,8BAA8B,UAAU;AACxC,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAC,IAAI;AACpB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,+BAA+B,WAAW;AAC1C,gCAAgC,aAAa;AAC7C,6BAA6B,SAAS;AACtC,8BAA8B,UAAU;AACxC,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA,oBAAoB,4DAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAC,IAAI;AACpB;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C,gCAAgC,cAAc;AAC9C,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,4BAA4B,8CAAE;AAC9B,2BAA2B,8CAAE;AAC7B,uBAAuB,8CAAE;AACzB,6BAA6B,8CAAE;AAC/B,uBAAuB,8CAAE;AACzB,2BAA2B,8CAAE;AAC7B;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C,gCAAgC,cAAc;AAC9C,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,4BAA4B,4DAAa;AACzC;AACA,2BAA2B,8CAAE;AAC7B,uBAAuB,8CAAE;AACzB,6BAA6B,4DAAa;AAC1C;AACA,uBAAuB,8CAAE;AACzB,2BAA2B,8CAAE;AAC7B;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACQ;;;;;;;;;;;;;ACnKvB;AAAA;AAAA;AAAA;AAAkC;AACE;AACpC;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,6CAA6C,WAAW,KAAK,WAAW;AACxE;AACA,uDAAuD;AACvD,6CAA6C;AAC7C;AACA,kCAAkC,OAAO,KAAK,OAAO;AACrD;AACA,mCAAmC,gDAAU,GAAG;AAChD,kCAAkC,gDAAU;AAC5C,uCAAuC,gDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,KAAK,mBAAmB;AAC7E,uDAAuD;AACvD,8CAA8C;AAC9C;AACA,kCAAkC,QAAQ,KAAK,QAAQ;AACvD;AACA,4BAA4B;AAC5B;AACA;AACA,6CAA6C,QAAQ,KAAK,QAAQ;AAClE;AACA,mBAAmB,8CAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,oCAAoC;AACpC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA,2BAA2B,UAAU;AACrC,6CAA6C;AAC7C;AACA,8BAA8B;AAC9B,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,8BAA8B,gBAAgB;AAC9C;AACA;AACA,uCAAuC;AACvC,yCAAyC;AACzC,yCAAyC;AACzC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACiB;;;;;;;;;;;;;AC1OlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI,SAAS,OAAO,KAAK,OAAO,KAAK,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE,yCAAyC,6BAA6B;AACtE,wCAAwC,6BAA6B;AACrE;AACA,CAAC;AACgB;;;;;;;;;;;;;ACjLjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC+C;AACpB;AACM;AACF;AACF;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAE;AAC5B,0BAA0B,4CAAK;AAC/B,6BAA6B;AAC7B;AACA,uBAAuB,gDAAC;AACxB;AACA,mBAAmB,0CAAI;AACvB,QAAQ,0CAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iCAAiC;AAC/E;AACA;AACA;AACA,oDAAoD,uCAAuC;AAC3F;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA,CAAC;AACiB;;;;;;;;;;;;;ACzDlB;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC8B;AACE;AAChC;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B,QAAQ,0CAAI;AACZ;AACA;AACA;AACA;AACA,kCAAkC,4CAAK;AACvC;AACA;AACA,6BAA6B,4CAAK,QAAQ;AAC1C;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;;;;;;;;;;;;;AChDpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC+C;AAChB;AACI;AACJ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA,kCAAkC,4CAAK;AACvC;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACE;;;;;;;;;;;;;ACtEjB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,MAAM;AACN;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,EAAE;AACnB,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA,aAAa;AACb;AACA,MAAM;AACN;AACA,CAAC,IAAI;AACiB;;;;;;;;;;;;;ACrEtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,OAAO;AAC9B,gBAAgB,8CAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;;;;;;;;;;;;;AChJP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4C;AAC5C;AACA,WAAW,cAAc;AACO;AACI;AACF;AAClC;AACA;AACA;AACA,yBAAyB,4CAAK;AAC9B;AACA;AACA,0BAA0B,8CAAM;AAChC;AACA;AACA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgB;;;;;;;;;;;;;ACvKjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACiC;AACF;AAChC;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,4CAAK;AACxB;AACA;AACA,CAAC;AACiB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACkB;;;;;;;;;;;;;ACzKnB;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC+C;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACE;AACjB;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC4B;AACQ;AACJ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACO;AACP,kBAAkB,gDAAC,WAAW,gDAAC,WAAW,gDAAC;AAC3C,eAAe,4CAAK;AACpB;AACA;AACA,0BAA0B,gDAAC,WAAW,gDAAC,WAAW,gDAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4CAAK;AACiB;AACxB,kBAAkB,gDAAC,cAAc,gDAAC,aAAa,gDAAC,aAAa,gDAAC,YAAY,gDAAC,aAAa,gDAAC,YAAY,gDAAC,YAAY,gDAAC;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4CAAK;AACS;AAChB,qBAAqB,gDAAC,WAAW,gDAAC,WAAW,gDAAC,WAAW,gDAAC,WAAW,gDAAC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4CAAK;AACY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL,IAAI,gDAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4CAAK;AACgB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAA6C,6BAA6B,iBAAiB;AACnH;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,gDAAO;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,WAAW,WAAW;AACQ;AACS;AACU;AACf;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAE;AAC/B,wCAAwC,8CAAE;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAQ;AACzC,mCAAmC,mDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAQ;AACxC;AACA;AACA;AACA,kCAAkC,mDAAQ;AAC1C;AACA;AACA;AACA,CAAC,CAAC,4DAAa;AACI;;;;;;;;;;;;;AC7FnB;AAAA;AAAA;AAAA;AAAA;AAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,8CAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAE,WAAW;AAClC,6BAA6B,8CAAE,YAAY;AAC3C,0BAA0B,8CAAE;AAC5B,6BAA6B,8CAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,qBAAqB,8CAAE;AACvB;AACA;AACA,0CAA0C,8CAAE;AAC5C,0CAA0C,8CAAE;AAC5C,0CAA0C,8CAAE;AAC5C;AACA;AACA;AACA,CAAC;AACwB;;;;;;;;;;;;;ACvFzB;AAAA;AAAA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACe;;;;;;;;;;;;;AC5ChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACa;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACa;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,CAAC;AACa;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACa;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACa;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACa;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACe","file":"seen_ts.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./demo.ts\");\n","import { Scene } from \"./src/Seen2\";\r\nimport { Canvas } from \"./src/canvas\";\r\n//import {P} from \"./src/point\"\r\nimport { Icosahedron, TestTriangle } from './src/shapes/primitives';\r\nimport { V3 } from \"./src/vectorMath\";\r\nimport { Color } from \"./src/color\";\r\nvar width = 900;\r\nvar height = 500;\r\nvar ctx = new Canvas('seen-canvas');\r\n// ////////////////// threeJS syntax  /////////////////\r\n// var scene = new Scene();\r\n// var camera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\r\n// var renderer = new THREE.WebGLRenderer();\r\n// renderer.setSize( window.innerWidth, window.innerHeight );\r\n// document.body.appendChild( renderer.domElement );\r\n// var geometry = new THREE.BoxGeometry( 1, 1, 1 );\r\n// var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\r\n// var cube = new THREE.Mesh( geometry, material );\r\n// scene.add( cube );\r\n// camera.position.z = 5;\r\n// function animate() {\r\n// \trequestAnimationFrame( animate );\r\n// \trenderer.render( scene, camera );\r\n// \r\n// animate();\r\n// ////////////////// SEEN_TS  syntax  /////////////////\r\nvar scene = new Scene('seen-canvas'); // includes the camera, renderer is always CANVAS\r\n// let pyramid = new Pyramid({ color: 0x00ff00 })   // defaults to basic material\r\n// let cube = new Cube({ color: 0x0000ff })\r\nvar ico = new Icosahedron({ color: 0x0000ff });\r\n// let ico2 = new Icosahedron({ color: 0x0000ff })\r\nvar tt = new TestTriangle();\r\n// scene.add (tt)\r\nscene.add(ico);\r\nico.scale = new V3([50, 50, 50]);\r\n// scene.add(ico2)\r\n// ico.rotation = new V3([.1, .1, .1])\r\n// console.log(ico.rotation)\r\n// ico.rotation.x += .2\r\n// console.log('ico matrix',ico.m)\r\n// console.log('ico matrix after',ico.m)\r\n// ico.scale = new V3 ([10,10,10])\r\n// ico.scale.x += .2\r\n// ico2.position = new V3([10,10,10])\r\n// console.log('ico2 position', ico2.position)\r\n// scene.render()\r\nvar x = 10;\r\nvar y = 10;\r\nvar animate = function () {\r\n    ico.position.x += .01;\r\n    ico.rotation.x += .01;\r\n    // ico.rotation.y += .01\r\n    // // //ico.scale.x += .01\r\n    //    scene.render()\r\n    canvasPixelTest();\r\n    scene.canvas.updateDisplay();\r\n};\r\nscene.canvas.animationObservable.addObserver('tick', animate);\r\nfunction canvasPixelTest() {\r\n    scene.canvas.setPixelColor(x++, y, new Color('//FF0000'));\r\n    scene.canvas.setPixelColor(x++, y, new Color('//00FF00'));\r\n    scene.canvas.setPixelColor(x++, y, new Color('//0000FF'));\r\n    scene.canvas.setPixelRBG(x++, y + 10, 0, 255, 0);\r\n}\r\n// // create a cube\r\n// let shape = Cube()\r\n// console.log('shape',shape)\r\n// shape.render()\r\n// Create scene and add cube to model\r\n// let scene = new Scene();\r\n// console.log('SCENE',scene)\r\n// let shape = pyramid()\r\n// console.log('SHAPE',shape)\r\n// let model = new Group(shape)\r\n// console.log('MODEL',model)\r\n// scene.model = model\r\n// scene.render()\r\n// let viewport = new Viewport.center(width, height)\r\n// Create sphere shape with randomly colored surfaces\r\n//let shape = seen.Shapes.sphere(2).scale(height * 0.4)\r\n//let shape = Shapes.cube().scale(height * 0.2)\r\n//let shape = new Shapes().pyramid()//.scale(height * 0.2)\r\n////////////// this works\r\n// let points = [P(-1, -1, -1), P(-1, -1, 1), P(-1, 1, -1), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];\r\n// points = [P(10,10,10), P(20,20,20), P(10,20,30), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];\r\n// //console.log(points);\r\n// ctx.path(points);\r\n// ctx.fill({fillStyle: 'yellow'})\r\n// ctx.draw({strokeStyle:'rgb(0,128,0)',lineWidth: 3})\r\n// console.log('done')\r\n///////////////////\r\n//seen.Colors.randomSurfaces2(shape)\r\n//console.log(shape)\r\n// // Create render context from canvas\r\n// let context = seen.Context('seen-canvas', scene).render()\r\n// // Slowly rotate\r\n// context.animate().onBefore(function (t, dt) {\r\n//   return shape.rotx(dt * 1e-3).roty(0.7 * dt * 1e-3);\r\n// }).start();\r\n","// Aggregate submodules together in a parent module.\r\n//\r\n// supports\r\n//    import {Scene, Matrix} from 'seen'\r\nexport { Scene } from './scene';\r\nexport { Group } from './model';\r\nexport { Primitive } from './shapes/primitives';\r\nexport { Viewport } from \"./camera\"; // TODO: should this be exported, or is it just part of camera?\r\nexport { Shape } from './shape';\r\nexport { P } from './point';\r\n","// //// Camera\r\n// //////// Projections, Viewports, and Cameras\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { M, Transformable } from './transformable';\r\nimport { V3, M4 } from './vectorMath';\r\n// These projection methods return a 3D to 2D `Matrix` transformation.\r\n// Each projection assumes the camera is located at (0,0,0).\r\nvar Projection = /** @class */ (function () {\r\n    function Projection() {\r\n    }\r\n    // Creates a perspective projection matrix\r\n    Projection.perspectiveFov = function (fovyInDegrees, front) {\r\n        if (fovyInDegrees === void 0) { fovyInDegrees = 50; }\r\n        if (front === void 0) { front = 1; }\r\n        var tan = front * Math.tan(fovyInDegrees * Math.PI / 360.0);\r\n        return this.perspective(-tan, tan, -tan, tan, front, 2 * front);\r\n    };\r\n    /** Creates a perspective projection matrix with the supplied frustrum */\r\n    Projection.perspective = function (left, right, bottom, top, near, far) {\r\n        if (left === void 0) { left = -1; }\r\n        if (right === void 0) { right = 1; }\r\n        if (bottom === void 0) { bottom = -1; }\r\n        if (top === void 0) { top = 1; }\r\n        if (near === void 0) { near = 1; }\r\n        if (far === void 0) { far = 100; }\r\n        var near2 = 2 * near;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        var m = new Array(16);\r\n        m[0] = near2 / dx;\r\n        m[1] = 0.0;\r\n        m[2] = (right + left) / dx;\r\n        m[3] = 0.0;\r\n        m[4] = 0.0;\r\n        m[5] = near2 / dy;\r\n        m[6] = (top + bottom) / dy;\r\n        m[7] = 0.0;\r\n        m[8] = 0.0;\r\n        m[9] = 0.0;\r\n        m[10] = -(far + near) / dz;\r\n        m[11] = -(far * near2) / dz;\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = -1.0;\r\n        m[15] = 0.0;\r\n        return M(m); // Matrix class\r\n    };\r\n    /** Creates a orthographic projection matrix with the supplied frustrum */\r\n    Projection.ortho = function (left, right, bottom, top, near, far) {\r\n        if (left === void 0) { left = -1; }\r\n        if (right === void 0) { right = 1; }\r\n        if (bottom === void 0) { bottom = -1; }\r\n        if (top === void 0) { top = 1; }\r\n        if (near === void 0) { near = 1; }\r\n        if (far === void 0) { far = 100; }\r\n        var near2 = 2 * near;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        var t = new Transformable;\r\n        var m = new Array(16);\r\n        m[0] = 2 / dx;\r\n        m[1] = 0.0;\r\n        m[2] = 0.0;\r\n        m[3] = (right + left) / dx;\r\n        m[4] = 0.0;\r\n        m[5] = 2 / dy;\r\n        m[6] = 0.0;\r\n        m[7] = -(top + bottom) / dy;\r\n        m[8] = 0.0;\r\n        m[9] = 0.0;\r\n        m[10] = -2 / dz;\r\n        m[11] = -(far + near) / dz;\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = 0.0;\r\n        m[15] = 1.0;\r\n        return M(m); // matrix class\r\n    };\r\n    return Projection;\r\n}());\r\nexport { Projection };\r\nvar Viewport = /** @class */ (function () {\r\n    function Viewport() {\r\n        this.center(500, 500, 0, 0);\r\n    }\r\n    /** Create a viewport where the scene's origin is centered in the view */\r\n    Viewport.prototype.center = function (width, height, x, y) {\r\n        if (width === void 0) { width = 500; }\r\n        if (height === void 0) { height = 500; }\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        this.prescale = new M4()\r\n            .translate(new V3([-x, -y, -height]))\r\n            .scale(new V3([1 / width, 1 / height, 1 / height]));\r\n        this.postscale = new M4()\r\n            .scale(new V3([width, -height, height]))\r\n            .translate(new V3([x + width / 2, y + height / 2, height]));\r\n    };\r\n    /** Create a view port where the scene's origin is aligned with the origin ([0, 0]) of the view */\r\n    Viewport.prototype.origin = function (width, height, x, y) {\r\n        if (width === void 0) { width = 500; }\r\n        if (height === void 0) { height = 500; }\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        this.prescale = new Transformable()\r\n            .m\r\n            .translate(new V3([-x, -y, -1]))\r\n            .scale(new V3([1 / width, 1 / height, 1 / height]));\r\n        this.postscale = new Transformable()\r\n            .m\r\n            .scale(new V3([width, -height, height]))\r\n            .translate(new V3([x, y, 1]));\r\n        return this;\r\n    };\r\n    return Viewport;\r\n}());\r\nexport { Viewport };\r\n// The `Camera` model contains all three major components of the 3D to 2D tranformation.\r\n//\r\n// First, we transform object from world-space (the same space that the coordinates of\r\n// surface points are in after all their transforms are applied) to camera space. Typically,\r\n// this will place all viewable objects into a cube with coordinates:\r\n// x = -1 to 1, y = -1 to 1, z = 1 to 2\r\n//\r\n// Second, we apply the projection transform to create perspective parallax and what not.\r\n//\r\n// Finally, we rescale to the viewport size.\r\n//\r\n// These three steps allow us to easily create shapes whose coordinates match up to\r\n// screen coordinates in the z = 0 plane.\r\nvar Camera = /** @class */ (function (_super) {\r\n    __extends(Camera, _super);\r\n    function Camera(options) {\r\n        var _this = _super.call(this) || this;\r\n        //seen.Util.defaults(this., options, this.defaults)\r\n        _this.m = Projection.perspective();\r\n        return _this;\r\n    }\r\n    return Camera;\r\n}(Transformable));\r\nexport { Camera };\r\nvar PixelCamera = /** @class */ (function (_super) {\r\n    __extends(PixelCamera, _super);\r\n    function PixelCamera() {\r\n        return _super.call(this) || this;\r\n    }\r\n    return PixelCamera;\r\n}(Transformable));\r\nexport { PixelCamera };\r\n","import { V2 } from './vectorMath';\r\nimport { Observable } from './paon';\r\n///////////////////////////////////////////////////////////////////////\r\n// palette\r\n// https://digitalsynopsis.com/design/beautiful-color-palettes-combinations-schemes/\r\n// beach towel\r\nvar COLOR1 = '#fe4a49'; // red\r\nvar COLOR2 = '#2ab7ca'; // blue\r\nvar COLOR3 = '#fed766'; // yellow\r\nvar BKGND = '#e6e6ea';\r\nvar CLEAR = '#f4f4f8';\r\n///////////////////////////////////////////////////////////////////////\r\nvar Canvas = /** @class */ (function () {\r\n    function Canvas(canvasTag) {\r\n        // console.log(`in Canvas construtor for tag '${canvasTag}'`)\r\n        this.x = 0;\r\n        this.canvas = document.getElementById(canvasTag);\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.width = this.canvas.width;\r\n        this.height = this.canvas.height;\r\n        this.clearDisplay(); // clear the canvas to transparent black\r\n        //    // find out more about the canvas...\r\n        // let containerX = document.getElementById('container').offsetLeft\r\n        // let containerY = document.getElementById('container').offsetTop\r\n        // console.log(`container offset x=${containerX},y=${containerY}`)\r\n        // some devices might scale, so scaleX/Y will not be close to 1\r\n        var rect = this.canvas.getBoundingClientRect(); // position of canvas\r\n        var scaleX = this.width / rect.width; // relationship bitmap vs. element for X\r\n        var scaleY = this.height / rect.height;\r\n        // console.log(`scale x=${scaleX},y=${scaleY}`)\r\n        /// this section sets up keyboard and mouse events for this canvas\r\n        this.mouseObservable = new Observable(); // watch for input field to fill\r\n        this.kybdObservable = new Observable();\r\n        this.animationObservable = new Observable();\r\n        // add event listeners\r\n        this.canvas.addEventListener('mousedown', this.canvasMousedown.bind(this));\r\n        document.addEventListener('keypress', this.canvasKeypress.bind(this));\r\n        window.requestAnimationFrame(this.canvasAnimation.bind(this));\r\n    }\r\n    //  not used yet, not tested yet\r\n    Canvas.prototype.removeListeners = function () {\r\n        this.canvas.removeEventListener('mousedown', this.canvasMousedown);\r\n        document.removeEventListener('keypress', this.canvasKeypress);\r\n    };\r\n    Canvas.prototype.canvasAnimation = function (timestamp) {\r\n        // if (!start) start = timestamp;\r\n        // var progress = timestamp - start;\r\n        // element.style.transform = 'translateX(' + Math.min(progress / 10, 200) + 'px)';\r\n        // if (progress < 2000) {\r\n        this.animationObservable.notifyObservers('tick', event);\r\n        window.requestAnimationFrame(this.canvasAnimation.bind(this));\r\n    };\r\n    Canvas.prototype.canvasKeypress = function (event) {\r\n        // console.log('in canvasKeypress event', event)\r\n        this.kybdObservable.notifyObservers('keypress', event);\r\n    };\r\n    Canvas.prototype.canvasMousedown = function (event) {\r\n        // console.log('in canvasMousedown event', event)\r\n        this.mouseObservable.notifyObservers('mousedown', event);\r\n    };\r\n    /* if a mouse has landed, this retrieves the point relative to this canvas */\r\n    Canvas.prototype.getMouseXY = function (event) {\r\n        // console.log(`canvas x=${this.canvas.width},y=${this.canvas.height}`)\r\n        var rect = this.canvas.getBoundingClientRect(); // position of canvas\r\n        var canvasX = event.pageX - rect.left; // now relative within canvas\r\n        var canvasY = event.pageY - rect.top;\r\n        // console.log(`mouse x=${canvasX},y=${canvasY}`)\r\n        // event.offset is more accurate, but not always available\r\n        if (event.offsetX) { // for webkit browser like safari and chrome\r\n            canvasX = event.offsetX;\r\n            canvasY = event.offsetY;\r\n            // console.log(`event offset x=${canvasX},y=${canvasY}`)\r\n        }\r\n        return new V2([canvasX, canvasY]);\r\n    };\r\n    Canvas.prototype.clearCanvas = function () {\r\n        this.ctx.fillStyle = BKGND;\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        // clearRect is like fillRect, but sets transparent black pxls.  also faster.\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        // fillRect obays the BKGND color\r\n        //this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\r\n    };\r\n    // layer (layer) {\r\n    //   this.layers.push {\r\n    //     layer   : layer\r\n    //     context : new seen.CanvasLayerRenderContext(this.ctx)\r\n    //   }\r\n    //   return this\r\n    // }\r\n    // reset() {\r\n    //     this.ctx.setTransform(1, 0, 0, 1, 0, 0)\r\n    //     this.ctx.clearRect(0, 0, this.el.width, this.el.height)\r\n    // }\r\n    Canvas.prototype.draw = function (style) {\r\n        // Copy over SVG CSS attributes\r\n        if (style.strokeStyle)\r\n            this.ctx.strokeStyle = style.strokeStyle;\r\n        // TODO: which do we need of the rest?  Can we deal with them as a class?\r\n        if (style.lineWidth)\r\n            this.ctx.lineWidth = style.lineWidth;\r\n        // if (style.textAnchor)\r\n        //     this.ctx.textAlign = style.textAnchor\r\n        this.ctx.stroke();\r\n        return this;\r\n    };\r\n    Canvas.prototype.fill = function (style) {\r\n        // Copy over SVG CSS attributes\r\n        if (style.fillStyle)\r\n            this.ctx.fillStyle = style.fillStyle;\r\n        // console.log('fillStyle',style.fillStyle)\r\n        // if (style['text-anchor'])\r\n        //     this.ctx.textAlign = style['text-anchor']\r\n        // if (style['fill-opacity'])\r\n        //     this.ctx.globalAlpha = style['fill-opacity']\r\n        this.ctx.fill();\r\n        return this;\r\n    };\r\n    /** Create a polygon path for a CANVAS rendering */\r\n    Canvas.prototype.path = function (points) {\r\n        this.ctx.beginPath();\r\n        for (var i = 0, j = 0, len = points.length; j < len; i = ++j) {\r\n            var p = points[i];\r\n            // tom's kluge for now /////////////////////\r\n            // scale points by 10, and move them to 50,50\r\n            if (i === 0) {\r\n                this.ctx.moveTo(p.x * 50 + 50, p.y * 50 + 50);\r\n                console.log('moveTo', p.x * 50 + 50, p.y * 50 + 50);\r\n            }\r\n            else {\r\n                this.ctx.lineTo(p.x * 50 + 50, p.y * 50 + 50);\r\n                console.log('lineTo', p.x * 50 + 50, p.y * 50 + 50);\r\n            }\r\n        }\r\n        this.ctx.closePath();\r\n        return this;\r\n    };\r\n    Canvas.prototype.fillRect = function (x, y, width, height) {\r\n        console.log('fillRect', x * 50 + 50, y * 50 + 50, width, height);\r\n        this.ctx.fillRect(x * 50 + 50, y * 50 + 50, width, height);\r\n        return this;\r\n    };\r\n    Canvas.prototype.fillStyle = function (colour) {\r\n        this.ctx.fillStyle = colour;\r\n        return this;\r\n    };\r\n    Canvas.prototype.circle = function (center, radius) {\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, true);\r\n        return this;\r\n    };\r\n    Canvas.prototype.fillText = function (m, text, style) {\r\n        this.ctx.save();\r\n        this.ctx.setTransform(m[0], m[3], -m[1], -m[4], m[2], m[5]);\r\n        if (style.font)\r\n            this.ctx.font = style.font;\r\n        if (style.fill)\r\n            this.ctx.fillStyle = style.fill;\r\n        // TODO: string is not assignable...\r\n        // if (style['text-anchor'])\r\n        //     this.ctx.textAlign = this._cssToCanvasAnchor(style['text-anchor'])\r\n        this.ctx.fillText(text, 0, 0);\r\n        this.ctx.restore();\r\n        return this;\r\n    };\r\n    Canvas.prototype._cssToCanvasAnchor = function (anchor) {\r\n        if (anchor == 'middle')\r\n            return 'center';\r\n        return anchor;\r\n    };\r\n    ///////////////////////////////////////////////////////\r\n    //////// next functions write pixels to canvas \r\n    ///////////////////////////////////////////////////////\r\n    Canvas.prototype.setPixelColor = function (x, y, color) {\r\n        var index = (y * this.width + x) * 4; // note  * 4  because four bytes per\r\n        // console.log('color',color.r, color.b, color.g)\r\n        this.data8[index] = color.r; // red\r\n        this.data8[++index] = color.g; // green\r\n        this.data8[++index] = color.b; // blue\r\n        this.data8[++index] = color.a; // alpha\r\n    };\r\n    Canvas.prototype.setPixelRBG = function (x, y, R, B, G, A) {\r\n        if (A === void 0) { A = 0xFF; }\r\n        var index = (y * this.width + x) * 4; // note  *4  because four bytes per\r\n        // console.log('rgb',R, B, G)\r\n        this.data8[index] = R; // red\r\n        this.data8[++index] = G; // green\r\n        this.data8[++index] = B; // blue\r\n        this.data8[++index] = A; // alpha\r\n    };\r\n    Canvas.prototype.clearDisplay = function () {\r\n        this.imageData = this.ctx.createImageData(this.width, this.height); // reset to empty\r\n        this.data8 = new Uint8ClampedArray(this.imageData.data.length);\r\n    };\r\n    Canvas.prototype.updateDisplay = function () {\r\n        // update the screen from the 8-bit buffer\r\n        this.imageData.data.set(this.data8);\r\n        this.ctx.putImageData(this.imageData, 0, 0);\r\n        // note that the buffer has not been cleared\r\n    };\r\n    Canvas.prototype.demoImageData = function (color) {\r\n        this.imageData = this.ctx.getImageData(0, 0, this.width, this.height);\r\n        // let data = imageData.data;\r\n        // for (var y = 0; y < this.height; ++y) {\r\n        //     for (var x = 0; x < this.width; ++x) {\r\n        //         var index = (y * this.width + x) * 4  // NOTE - * 4\r\n        //         var value = x * y & 0xff;\r\n        //         data[index] = value;      // red\r\n        //         data[++index] = value;    // green\r\n        //         data[++index] = value;    // blue\r\n        //         data[++index] = 255;      // alpha\r\n        //     }\r\n        // }\r\n        // this.ctx.putImageData(imageData, 0, 0);\r\n        // let buf = new ArrayBuffer(imageData.data.length);\r\n        // let buf8 = new Uint8ClampedArray(buf);\r\n        // let data = new Uint32Array(buf);\r\n        // for (let y = 0; y < this.height; ++y) {\r\n        //     for (let x = 0; x < this.width; ++x) {\r\n        //         let value = x * y & color\r\n        //         // write to the 32-bit buffer\r\n        //         data[y * this.width + x] =\r\n        //              (255 << 24) |    // alpha  - 255 is fully opaque\r\n        //          //   (value << 16) |    // blue\r\n        //          //   (value << 8) |    // green\r\n        //             value             // red\r\n        //     }\r\n        // }\r\n        // // update the screen from the 8-bit buffer\r\n        // imageData.data.set(buf8);\r\n        // this.ctx.putImageData(imageData, 0, 0);\r\n    };\r\n    return Canvas;\r\n}());\r\nexport { Canvas };\r\n","// //// Colors\r\n// ------------------\r\n/** `Color` objects store RGB and Alpha values from 0 to 255. Default is gray. */\r\nvar Color = /** @class */ (function () {\r\n    /** eg: '//888888' */\r\n    function Color(hexString) {\r\n        if (hexString) {\r\n            this.hex(hexString);\r\n        }\r\n        else {\r\n            // consider supporting 140 names from https://htmlcolorcodes.com/\r\n            // default is gray    \r\n            this.hex('//888888');\r\n        }\r\n        return this;\r\n    }\r\n    /** Returns a new `Color` object with the same rgb and alpha values as the current object */\r\n    Color.prototype.copy = function () {\r\n        return new Color(this.hexString());\r\n    };\r\n    /** Scales the rgb channels by the supplied scalar value. */\r\n    Color.prototype.scale = function (n) {\r\n        this.r *= n;\r\n        this.g *= n;\r\n        this.b *= n;\r\n        return this;\r\n    };\r\n    /** Offsets each rgb channel by the supplied scalar value. */\r\n    Color.prototype.offset = function (n) {\r\n        this.r += n;\r\n        this.g += n;\r\n        this.b += n;\r\n        return this;\r\n    };\r\n    /** Clamps each rgb channel to the supplied minimum and maximum scalar values. */\r\n    Color.prototype.clamp = function (min, max) {\r\n        if (min === void 0) { min = 0; }\r\n        if (max === void 0) { max = 0xFF; }\r\n        this.r = Math.min(max, Math.max(min, this.r));\r\n        this.g = Math.min(max, Math.max(min, this.g));\r\n        this.b = Math.min(max, Math.max(min, this.b));\r\n        return this;\r\n    };\r\n    /** Takes the minimum between each channel of this `Color` and the supplied `Color` object. */\r\n    Color.prototype.minChannels = function (c) {\r\n        this.r = Math.min(c.r, this.r);\r\n        this.g = Math.min(c.g, this.g);\r\n        this.b = Math.min(c.b, this.b);\r\n        return this;\r\n    };\r\n    /** Adds the channels of the current `Color` with each respective channel from the supplied `Color` object. */\r\n    Color.prototype.addChannels = function (c) {\r\n        this.r += c.r;\r\n        this.g += c.g;\r\n        this.b += c.b;\r\n        return this;\r\n    };\r\n    /** Multiplies the channels of the current `Color` with each respective channel from the supplied `Color` object. */\r\n    Color.prototype.multiplyChannels = function (c) {\r\n        this.r *= c.r;\r\n        this.g *= c.g;\r\n        this.b *= c.b;\r\n        return this;\r\n    };\r\n    /** Converts the `Color` into a hex string of the form \"//RRGGBB\". */\r\n    Color.prototype.hexString = function () {\r\n        var c = (this.r << 16 | this.g << 8 | this.b).toString(16);\r\n        while (c.length < 6) {\r\n            c = '0' + c;\r\n        }\r\n        return '//' + c;\r\n    };\r\n    // Converts the `Color` into a CSS-style string of the form \"rgba(RR, GG, BB, AA)\"\r\n    Color.prototype.style = function () {\r\n        return \"rgba(//{this.r},//{this.g},//{this.b},//{this.a})\";\r\n    };\r\n    // Parses a hex string starting with an octothorpe (//) or an rgb/rgba CSS\r\n    // string. Note that the CSS rgba format uses a float value of 0-1.0 for\r\n    /** alpha, but seen uses an in from 0-255. */\r\n    Color.prototype.parse = function (str) {\r\n        if (str.charAt(0) === '#' && str.length === 7) {\r\n            return this.hex(str);\r\n        }\r\n        else if (str.indexOf('rgb') === 0) {\r\n            var m = this.CSS_RGBA_STRING_REGEX.exec(str);\r\n            if (m == null) {\r\n                return this.black();\r\n            }\r\n            var a = m[6] != null ? Math.round(parseFloat(m[6]) * 0xFF) : void 0;\r\n            return this.rgb(parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), a);\r\n        }\r\n        else {\r\n            return this.black();\r\n        }\r\n    };\r\n    /** Loads the  `Color` using the supplied rgb and alpha values.\r\n    Each value must be in the range [0, 255] or, equivalently, [0x00, 0xFF]. */\r\n    Color.prototype.rgb = function (r, g, b, a) {\r\n        if (a === void 0) { a = 0xFF; }\r\n        this.r = r;\r\n        this.b = b;\r\n        this.g = g;\r\n        this.a = a;\r\n        return this;\r\n    };\r\n    // Creates a new `Color` using the supplied hex string of the form \"//RRGGBB\".\r\n    Color.prototype.hex = function (hex) {\r\n        if (hex.substring(0, 2) === '//')\r\n            hex = hex.substring(2);\r\n        this.r = parseInt(hex.substring(0, 2), 16);\r\n        this.b = parseInt(hex.substring(2, 4), 16);\r\n        this.g = parseInt(hex.substring(4, 6), 16);\r\n        this.a = 255;\r\n        // console.log(`hex(${hex}) is r:${this.r},b:${this.b},g:${this.g}`)\r\n        return this;\r\n    };\r\n    /** Creates a new `Color` using the supplied hue, saturation, and lightness (HSL) values.\r\n     Each value must be in the range [0.0, 1.0]. */\r\n    Color.prototype.hsl = function (h, s, l, a) {\r\n        if (a === void 0) { a = 1; }\r\n        var r, g, b;\r\n        r = g = b = 0;\r\n        if (s == 0) // When saturation is 0, the color is \"achromatic\" or \"grayscale\".\r\n            r = g = b = l;\r\n        else {\r\n            var q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\r\n            var p = 2 * l - q;\r\n            r = this.hue2rgb(p, q, h + 1 / 3);\r\n            g = this.hue2rgb(p, q, h);\r\n            b = this.hue2rgb(p, q, h - 1 / 3);\r\n        }\r\n        return this.rgb(r * 255, g * 255, b * 255, a * 255);\r\n    };\r\n    Color.prototype.hue2rgb = function (p, q, t) {\r\n        if (t < 0) {\r\n            t += 1;\r\n        }\r\n        else if (t > 1) {\r\n            t -= 1;\r\n        }\r\n        if (t < 1 / 6) {\r\n            return p + (q - p) * 6 * t;\r\n        }\r\n        else if (t < 1 / 2) {\r\n            return q;\r\n        }\r\n        else if (t < 2 / 3) {\r\n            return p + (q - p) * (2 / 3 - t) * 6;\r\n        }\r\n        else {\r\n            return p;\r\n        }\r\n    };\r\n    // /** Generates a new random color for each surface of the supplied `Shape`. */\r\n    // randomSurfaces(shape: Shape, sat: number = 0.5, lit: number = 0.4) {\r\n    //     shape.forEach(element => {\r\n    //         surface.fill(Colors.hsl(Math.random(), sat, lit))\r\n    //     })\r\n    // }\r\n    //   // Generates a random hue then randomly drifts the hue for each surface of\r\n    //   // the supplied `Shape`.\r\n    //   randomSurfaces2 : (shape, drift = 0.03, sat = 0.5, lit = 0.4) ->\r\n    //     hue = Math.random()\r\n    //     for surface in shape.surfaces\r\n    //       hue += (Math.random() - 0.5) * drift\r\n    //       while hue < 0 then hue += 1\r\n    //       while hue > 1 then hue -= 1\r\n    //       surface.fill seen.Colors.hsl(hue, 0.5, 0.4)\r\n    //   /** Generates a random color then sets the fill for every surface of the supplied `Shape`. */\r\n    //   randomShape : (shape:Shape, sat:number = 0.5, lit:number = 0.4) ->\r\n    //     shape.fill (new Material (this.hsl(Math.random()), sat, lit)\r\n    // A few `Color`s are supplied for convenience.\r\n    Color.prototype.black = function () { return this.hex('//000000'); };\r\n    Color.prototype.white = function () { return this.hex('//FFFFFF'); };\r\n    Color.prototype.gray = function () { return this.hex('//888888'); };\r\n    return Color;\r\n}());\r\nexport { Color };\r\n","// //// Lights\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Transformable } from './transformable';\r\nimport { P } from './point';\r\nimport { V4 } from './vectorMath';\r\nimport { Color } from './color';\r\nimport { Util } from './util';\r\n// This model object holds the attributes and transformation of a light source.\r\nvar Light = /** @class */ (function (_super) {\r\n    __extends(Light, _super);\r\n    function Light(type, options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.point = new V4();\r\n        _this.color = new Color().white();\r\n        _this.type = 'point'; // directional, ambient\r\n        _this.intensity = 0.01;\r\n        _this.normal = P(1, -1, -1).normalize();\r\n        _this.enabled = true;\r\n        _this.id = Util.uniqueId('L');\r\n        Util.defaults(_this, options, _this.defaults);\r\n        return _this;\r\n    }\r\n    Light.prototype.render = function () {\r\n        this.colorIntensity = this.color.copy().scale(this.intensity);\r\n    };\r\n    return Light;\r\n}(Transformable));\r\nexport { Light };\r\nvar Lights = /** @class */ (function () {\r\n    function Lights() {\r\n    }\r\n    // A point light emits light eminating in all directions from a single point.\r\n    // The `point` property determines the location of the point light. Note,\r\n    // though, that it may also be moved through the transformation of the light.\r\n    Lights.prototype.point = function (opts) { return new Light('point', opts); };\r\n    // A directional lights emit light in parallel lines, not eminating from any\r\n    // single point. For these lights, only the `normal` property is used to\r\n    // determine the direction of the light. This may also be transformed.\r\n    Lights.prototype.directional = function (opts) { return new Light('directional', opts); };\r\n    // Ambient lights emit a constant amount of light everywhere at once.\r\n    // Transformation of the light has no effect.\r\n    Lights.prototype.ambient = function (opts) { return new Light('ambient', opts); };\r\n    return Lights;\r\n}());\r\nexport { Lights };\r\n","// //// Materials\r\n// //////// Surface material properties\r\n// ------------------\r\nimport { Util } from './util';\r\nimport { Color } from './color';\r\n// `Material` objects hold the attributes that describe the color and finish of a surface.\r\nvar Material = /** @class */ (function () {\r\n    function Material(color, options) {\r\n        if (options === void 0) { options = {}; }\r\n        // The `metallic` attribute determines how the specular highlights are\r\n        // calculated. Normally, specular highlights are the color of the light\r\n        // source. If metallic is true, specular highlight colors are determined\r\n        // from the `specularColor` attribute.\r\n        this.metallic = false;\r\n        // The color used for specular highlights when `metallic` is true.\r\n        this.specularColor = new Color().white();\r\n        // The `specularExponent` determines how \"shiny\" the material is. A low\r\n        // exponent will create a low-intesity, diffuse specular shine. A high\r\n        // exponent will create an intense, point-like specular shine.\r\n        this.specularExponent = 15;\r\n        // A `Shader` object may be supplied to override the shader used for this\r\n        // material. For example, if you want to apply a flat color to text or\r\n        // other shapes, set this value to `seen.Shaders.Flat`.\r\n        this.shader = null; // TODO:\r\n        this.color = 'gray'; //Colors.gray()\r\n        Util.defaults(this, options, this.defaults);\r\n    }\r\n    Material.prototype.create = function (value) {\r\n        if (value instanceof Material)\r\n            return value;\r\n        else if (value instanceof Color)\r\n            return new Material(value);\r\n        else if (typeof (value) == 'string') {\r\n            this.color = new Color(value); //.parse(value))   \r\n            return this;\r\n        }\r\n        else\r\n            return this; // create() returns a Material object \r\n    };\r\n    // Apply the shader's shading to this material, with the option to override\r\n    // the shader with the material's shader (if defined).\r\n    Material.prototype.render = function (lights, shader, renderData) {\r\n        var color = shader.shade(lights, renderData, this);\r\n        color.a = this.color.a;\r\n        return color;\r\n    };\r\n    return Material;\r\n}());\r\nexport { Material };\r\n","// //// Groups\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Transformable } from './transformable';\r\nimport { Light } from './light';\r\nimport { Surface } from './surface';\r\nimport { Shape } from './shape';\r\n// The object group class. It stores `Shapes`, `Lights`, and sub-Groups\r\n// Notably, models are hierarchical, like a tree. This means you can isolate\r\n// the transformation of groups of shapes in the scene, as well as create\r\n// chains of transformations for creating, for example, articulated skeletons.\r\nvar Group = /** @class */ (function (_super) {\r\n    __extends(Group, _super);\r\n    function Group() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.groups = []; // sub-groups\r\n        _this.lights = [];\r\n        _this.surfaces = [];\r\n        _this.shapes = [];\r\n        return _this;\r\n        // /* Remove a shape, model, or light from the model. NOTE: the scene may still\r\n        // * contain a renderGroup in its cache. If you are adding and removing many items,\r\n        // * consider calling `.flush()` on the scene to flush its renderGroup cache. */\r\n        // remove : (childs...) ->\r\n        //   for child in childs\r\n        //     while (i = this.children.indexOf(child)) >= 0\r\n        //       this.children.splice(i,1)\r\n        //     while (i = this.lights.indexOf(child)) >= 0\r\n        //       this.lights.splice(i,1)\r\n        // // Create a new child model and return it.\r\n        // append: () ->\r\n        //   model = new seen.Group\r\n        //   this.add model\r\n        //   return model\r\n        // // Visit each `Shape` in this `Group` and all recursive child `Group`s.\r\n        // eachShape (f){\r\n        //   for child in this.children\r\n        //     if child instanceof seen.Shape\r\n        //       f.call(this., child)\r\n        //     if child instanceof seen.Group\r\n        //       child.eachShape(f)\r\n        //}\r\n    }\r\n    /** Add a `Shape`, `Surface`, Light`, and other `Group` */\r\n    Group.prototype.add = function (child) {\r\n        if (child instanceof Light)\r\n            this.lights.push(child);\r\n        else if (child instanceof Group)\r\n            this.groups.push(child);\r\n        else if (child instanceof Surface)\r\n            this.surfaces.push(child);\r\n        else if (child instanceof Shape)\r\n            this.shapes.push(child);\r\n        else // shouldn't get here\r\n            throw new Error('Tried to add something strange');\r\n    };\r\n    return Group;\r\n}(Transformable));\r\nexport { Group };\r\n","// paon.ts\r\n/**\r\n * Observable (subject/publisher) component\r\n *\r\n * @export\r\n * @class Observable\r\n */\r\nvar Observable = /** @class */ (function () {\r\n    function Observable() {\r\n        this.observers = {};\r\n    } // constructor\r\n    /**\r\n     * Add an observer to a type of message\r\n     *\r\n     * @param   {string}   type       Type of messages the observer subscribes to\r\n     * @param   {Observer} observer   Observer\r\n     * @returns {Observer}            Observer\r\n     */\r\n    Observable.prototype.addObserver = function (type, observer, t) {\r\n        if (t === void 0) { t = this; }\r\n        if (!(type in this.observers)) {\r\n            this.observers[type] = [];\r\n        }\r\n        this.observers[type].push(observer.bind(t));\r\n        return observer;\r\n    }; // addObserver\r\n    /**\r\n     * Remove an observer from a type of message\r\n     *\r\n     * @param   {string}   type       Type of messages the observer subscribes to\r\n     * @param   {Observer} observer   Observer\r\n     * @returns {void}\r\n     */\r\n    Observable.prototype.removeObserver = function (type, observer) {\r\n        if (this.observers[type]) {\r\n            for (var i = 0; i < this.observers[type].length; i++) {\r\n                if (observer === this.observers[type][i]) {\r\n                    this.observers[type].splice(i, 1);\r\n                    return;\r\n                }\r\n            } // for i\r\n        }\r\n    }; // removeObserver\r\n    /**\r\n     * Remove all observers from a type of message\r\n     *\r\n     * @param   {string}   type       Type of messages the observers subscribe to\r\n     * @returns {void}\r\n     */\r\n    Observable.prototype.removeObserversType = function (type) {\r\n        delete this.observers[type];\r\n    }; // removeObserversType\r\n    /**\r\n     * Send a message to observers\r\n     *\r\n     * @param   {string} type    Type of message to be sent to observers\r\n     * @param   {*}      [msg]   Content of the message\r\n     * @returns {void}\r\n     */\r\n    Observable.prototype.notifyObservers = function (type, msg) {\r\n        if (type in this.observers) {\r\n            for (var _i = 0, _a = this.observers[type]; _i < _a.length; _i++) {\r\n                var obs = _a[_i];\r\n                obs(msg);\r\n            } // for obs\r\n        }\r\n    }; // notifyObservers\r\n    return Observable;\r\n}()); // Observable\r\nexport { Observable };\r\n","import { V4 } from \"./vectorMath\";\r\n// The `Point` object contains x,y,z, and w coordinates. `Point`s support\r\n// various arithmetic operations with other `Points`, scalars, or `Matrices`.\r\n//\r\n// Most of the methods on `Point` are destructive, so be sure to use `.copy()`\r\n// when you want to preserve an object's value.\r\n/**  Convenience method for creating a new `Point` object*/\r\nexport function P(x, y, z, w) {\r\n    if (w === void 0) { w = 1; }\r\n    return (new V4([x, y, z, w]));\r\n}\r\n// export class Point {\r\n//     x: number\r\n//     y: number\r\n//     z: number\r\n//     w: number\r\n//     constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 1) {\r\n//         this.x = x\r\n//         this.y = y\r\n//         this.z = z\r\n//         this.w = w\r\n//     }\r\n//     /** useful for looking at a point with console.log()  */\r\n//     show(): string {\r\n//         return (`P(${this.x}, ${this.y}, ${this.z}) `)\r\n//     }\r\n//     /** Creates and returns a new `Point` with the same values as this object. */\r\n//     copy() {\r\n//         return P(this.x, this.y, this.z, this.w)\r\n//     }\r\n//     /** Copies the values of the supplied `Point` into this object. */\r\n//     set(p: Point) {\r\n//         this.x = p.x\r\n//         this.y = p.y\r\n//         this.z = p.z\r\n//         this.w = p.w\r\n//         return this\r\n//     }\r\n//     // Performs parameter-wise addition with the supplied `Point`. Excludes `this.w`.\r\n//     add(q: Point) {\r\n//         this.x += q.x\r\n//         this.y += q.y\r\n//         this.z += q.z\r\n//         return this\r\n//     }\r\n//     // Performs parameter-wise subtraction with the supplied `Point`. Excludes `this.w`.\r\n//     subtract(q: Point) {\r\n//         this.x -= q.x\r\n//         this.y -= q.y\r\n//         this.z -= q.z\r\n//         return this\r\n//     }\r\n//     // Apply a translation.  Excludes `this.w`.\r\n//     translate(x: number, y: number, z: number) {\r\n//         this.x += x\r\n//         this.y += y\r\n//         this.z += z\r\n//         return this\r\n//     }\r\n//     // Multiplies each parameters by the supplied scalar value. Excludes `this.w`.\r\n//     multiply(n: number) {\r\n//         this.x *= n\r\n//         this.y *= n\r\n//         this.z *= n\r\n//         return this\r\n//     }\r\n//     // Divides each parameters by the supplied scalar value. Excludes `this.w`.\r\n//     divide(n: number) {\r\n//         this.x /= n\r\n//         this.y /= n\r\n//         this.z /= n\r\n//         return this\r\n//     }\r\n//     // Rounds each coordinate to the nearest integer. Excludes `this.w`.\r\n//     round() {\r\n//         this.x = Math.round(this.x)\r\n//         this.y = Math.round(this.y)\r\n//         this.z = Math.round(this.z)\r\n//         return this\r\n//     }\r\n//     // Divides this `Point` by its magnitude. If the point is (0,0,0) we return (0,0,1).\r\n//     normalize() {\r\n//         let n = this.magnitude()\r\n//         if (n == 0) // Strict zero comparison -- may be worth using an epsilon\r\n//             this.set(POINT_Z)\r\n//         else\r\n//             this.divide(n)\r\n//         return this\r\n//     }\r\n//     /** Returns a new point that is perpendicular to this point */\r\n//     perpendicular() {\r\n//         let n = this.copy().cross(POINT_Z)\r\n//         let mag = n.magnitude()\r\n//         if (mag !== 0)\r\n//             return n.divide(mag)\r\n//         // can't find perpendicular of z axis, so use x axis\r\n//         return this.copy().cross(POINT_X).normalize()\r\n//     }\r\n//     // Apply a transformation from the supplied `Matrix`.\r\n//     transform(matrix: M4): Point {  // TODO: fix up when Matrix is defined\r\n//         let r = POINT_POOL\r\n//         r.x = this.x * matrix.at(0) + this.y * matrix.at(1) + this.z * matrix.at(2) + this.w * matrix.at(3)\r\n//         r.y = this.x * matrix.at(4) + this.y * matrix.at(5) + this.z * matrix.at(6) + this.w * matrix.at(7)\r\n//         r.z = this.x * matrix.at(8) + this.y * matrix.at(9) + this.z * matrix.at(10) + this.w * matrix.at(11)\r\n//         r.w = this.x * matrix.at(12) + this.y * matrix.at(13) + this.z * matrix.at(14) + this.w * matrix.at(15)\r\n//         this.set(r)\r\n//         return (this)\r\n//     }\r\n//     // Returns this `Point`s magnitude squared. Excludes `this.w`.\r\n//     magnitudeSquared() {\r\n//         return this.dot(this)\r\n//     }\r\n//     // Returns this `Point`s magnitude. Excludes `this.w`.\r\n//     magnitude() {\r\n//         return Math.sqrt(this.magnitudeSquared())\r\n//     }\r\n//     // Computes the dot product with the supplied `Point`.\r\n//     dot(q: Point) {\r\n//         return this.x * q.x + this.y * q.y + this.z * q.z\r\n//     }\r\n//     /** Computes the cross product with the supplied `Point`. */\r\n//     cross(q: Point) {\r\n//         let r = POINT_POOL\r\n//         r.x = this.y * q.z - this.z * q.y\r\n//         r.y = this.z * q.x - this.x * q.z\r\n//         r.z = this.x * q.y - this.y * q.x\r\n//         this.set(r)\r\n//         return this\r\n//     }\r\n// }\r\n// // seen.Points = {\r\n// //   X    : -> seen.P(1, 0, 0)\r\n// //   Y    : -> seen.P(0, 1, 0)\r\n// //   Z    : -> seen.P(0, 0, 1)\r\n// //   ZERO : -> seen.P(0, 0, 0)\r\n// // }\r\n// // A pool object which prevents us from having to create new `Point` objects\r\n// // for various calculations, which vastly improves performance.\r\n// var POINT_POOL = P(0, 0, 0, 0)\r\n// A few useful `Point` objects. Be sure that you don't invoke destructive\r\n// methods on these objects.\r\nexport var POINT_ZERO = P(0, 0, 0);\r\nexport var POINT_X = P(1, 0, 0);\r\nexport var POINT_Y = P(0, 1, 0);\r\nexport var POINT_Z = P(0, 0, 1);\r\n","// //// Scene\r\nimport { Camera, Viewport } from './camera';\r\n// TODO resolve between RenderGroup and Group\r\n// import { RenderGroup } from './render/rendermodel'\r\nimport { Group } from './model';\r\nimport { Shaders } from './shaders';\r\nimport { Canvas } from './canvas';\r\n/** A `Scene` is the main object for a view of a scene. */\r\nvar Scene = /** @class */ (function () {\r\n    function Scene(domElementID, options) {\r\n        this.world = new Group();\r\n        // The `Camera`, which defines the projection transformation. The default\r\n        // projection is perspective.\r\n        this.camera = new Camera();\r\n        // The `Viewport`, which defines the projection from shape-space to\r\n        // projection-space then to screen-space. The default viewport is on a\r\n        // space from (0,0,0) to (1,1,1). To map more naturally to pixels, create a\r\n        // viewport with the same width/height as the DOM element.\r\n        this.viewport = new Viewport().origin(1, 1);\r\n        // The scene's shader determines which lighting model is used.\r\n        this.shader = new Shaders();\r\n        // The `cullBackfaces` boolean can be used to turn off backface-culling\r\n        // for the whole scene. Beware, turning this off can slow down a scene's\r\n        // rendering by a factor of 2. You can also turn off backface-culling for\r\n        // individual surfaces with a boolean on those objects.\r\n        this.cullBackfaces = true;\r\n        // The `fractionalPoints` boolean determines if we round the surface\r\n        // coordinates to the nearest integer. Rounding the coordinates before\r\n        // since it cuts down on the length of path data. Anecdotally, my speedup\r\n        // on a complex demo scene was 10 FPS. However, it does introduce a slight\r\n        // jittering effect when animating.\r\n        this.fractionalPoints = false;\r\n        // The `cache` boolean (default : true) enables a simple cache for\r\n        // renderGroups, which are generated for each surface in the scene. The\r\n        // cache is a simple Object keyed by the surface's unique id. The cache has\r\n        // no eviction policy. To flush the cache, call `.flushCache()`\r\n        this.cache = true;\r\n        this._renderGroupCache = {};\r\n        this.canvas = new Canvas(domElementID);\r\n        this.options = {\r\n            cache: true,\r\n            answer: 42\r\n        };\r\n        Object.assign(this.options, options);\r\n    }\r\n    /** Add a `Shape`, `Surface`, Light`, and other `Group` */\r\n    Scene.prototype.add = function (child) {\r\n        this.world.add(child);\r\n    };\r\n    // The primary method that produces the render models, which are then used\r\n    // by the `RenderContext` to paint the scene.\r\n    Scene.prototype.render = function () {\r\n        var _this = this;\r\n        // first find ALL the surfaces we eventually will have to draw\r\n        var visibleSurfaceList = [];\r\n        // will be recursive, but start at the top\r\n        var group = this.world;\r\n        // examine each shape in  this group\r\n        group.shapes.forEach(function (shape) {\r\n            shape.recalculateSurfaces(); // update ever surface position\r\n            // what is 'visible' depends on the position of the camera\r\n            // next line uses tricky 'push spread' to append\r\n            visibleSurfaceList.push.apply(// update ever surface position\r\n            visibleSurfaceList, shape.visibleSurfaces(_this.camera));\r\n        });\r\n        this.canvas.clearCanvas();\r\n        visibleSurfaceList.forEach(function (surface) {\r\n            surface.render(_this.canvas);\r\n            //surface.points.map((p) => console.log(p.show()))\r\n        });\r\n        return;\r\n        //////////////////////////////////////////////////////\r\n        //////////////////////////////////////////////////////\r\n        //////////////////////////////////////////////////////\r\n        32;\r\n        //   renderGroup.fill = (ref1 = surface.fillMaterial) != null ? ref1.render(lights, _this.shader, renderGroup.transformed) : void 0;\r\n        //   renderGroup.stroke = (ref2 = surface.strokeMaterial) != null ? ref2.render(lights, _this.shader, renderGroup.transformed) : void 0;\r\n        // Compute the projection matrix including the viewport and camera\r\n        // transformation matrices.\r\n        // \r\n        var projection = this.camera\r\n            .m\r\n            .multiply(this.viewport.prescale);\r\n        // TODO  .multiply(this.camera.projection)\r\n        var transform = this.world.m;\r\n        // TODO: ??? what is this?\r\n        // this.viewport   = this.viewport.postscale\r\n        var renderGroups = [];\r\n        // Compute transformed and projected geometry.\r\n        var results = [];\r\n        for (var i = 0, len = this.world.surfaces.length; i < len; i++) {\r\n            var surface = this.world.surfaces[i];\r\n            var renderGroup = this._renderSurface(surface, transform, projection, this.viewport);\r\n            // Test projected normal's z-coordinate for culling (if enabled).\r\n            // if ((!_this.cullBackfaces || !surface.cullBackfaces || renderGroup.projected.normal.z < 0) && renderGroup.inFrustrum) {\r\n            //   renderGroup.fill = (ref1 = surface.fillMaterial) != null ? ref1.render(lights, _this.shader, renderGroup.transformed) : void 0;\r\n            //   renderGroup.stroke = (ref2 = surface.strokeMaterial) != null ? ref2.render(lights, _this.shader, renderGroup.transformed) : void 0;\r\n            //   // Round coordinates (if enabled)\r\n            //   if (_this.fractionalPoints !== true) {\r\n            //     ref3 = renderGroup.projected.points;\r\n            //     for (j = 0, len1 = ref3.length; j < len1; j++) {\r\n            //       p = ref3[j];\r\n            //       p.round();\r\n            //     }\r\n            //   }\r\n            //   results.push(renderGroups.push(renderGroup));\r\n            // } else {\r\n            results.push(void 0);\r\n            //}\r\n        }\r\n    };\r\n    // this.model.eachRenderable(function(light, transform) {\r\n    //     // Compute light model data.\r\n    //     return new seen.LightRenderGroup(light, transform);\r\n    // }, (function(_this) {\r\n    //   return function(shape, lights, transform) {\r\n    //     var i, j, len, len1, p, ref, ref1, ref2, ref3, renderGroup, results, surface;\r\n    //       // Compute transformed and projected geometry.\r\n    //       ref = shape.surfaces;\r\n    //     results = [];\r\n    //     for (i = 0, len = ref.length; i < len; i++) {\r\n    //       surface = ref[i];\r\n    //       renderGroup = _this._renderSurface(surface, transform, projection, viewport);\r\n    //       // Test projected normal's z-coordinate for culling (if enabled).\r\n    //       if ((!_this.cullBackfaces || !surface.cullBackfaces || renderGroup.projected.normal.z < 0) && renderGroup.inFrustrum) {\r\n    //         renderGroup.fill = (ref1 = surface.fillMaterial) != null ? ref1.render(lights, _this.shader, renderGroup.transformed) : void 0;\r\n    //         renderGroup.stroke = (ref2 = surface.strokeMaterial) != null ? ref2.render(lights, _this.shader, renderGroup.transformed) : void 0;\r\n    //         // Round coordinates (if enabled)\r\n    //         if (_this.fractionalPoints !== true) {\r\n    //           ref3 = renderGroup.projected.points;\r\n    //           for (j = 0, len1 = ref3.length; j < len1; j++) {\r\n    //             p = ref3[j];\r\n    //             p.round();\r\n    //           }\r\n    //         }\r\n    //         results.push(renderGroups.push(renderGroup));\r\n    //       } else {\r\n    //         results.push(void 0);\r\n    //       }\r\n    //     }\r\n    //     return results;\r\n    //   };\r\n    // })(this));\r\n    /** Sort render models by projected z coordinate. This ensures that the surfaces\r\n     farthest from the eye are painted first. (Painter's Algorithm) */\r\n    Scene.prototype.renderGroups = function (a, b) {\r\n        return b.projected.barycenter.z - a.projected.barycenter.z;\r\n    };\r\n    /** Get or create the rendermodel for the given surface.\r\n        If `this.cache` is true, we cache these models to reduce object creation and recomputation. */\r\n    Scene.prototype._renderSurface = function (surface, transform, projection, viewport) {\r\n        // if (!this.options.cache)\r\n        //     return new RenderGroup(surface, transform, projection, viewport);\r\n        // let renderGroup = this._renderGroupCache[surface.id]\r\n        // if (!renderGroup)  //was existential operator\r\n        //     renderGroup = this._renderGroupCache[surface.id] = new Group(surface, transform, projection, viewport)\r\n        // else\r\n        //     renderGroup.update(transform, projection, viewport)\r\n        // return renderGroup\r\n    };\r\n    /** Removes all elements from the cache. This may be necessary if you add and\r\n     remove many shapes from the scene's models since this cache has no eviction policy. */\r\n    Scene.prototype.flushCache = function () {\r\n        this._renderGroupCache = {};\r\n    };\r\n    return Scene;\r\n}());\r\nexport { Scene };\r\n","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { POINT_Z } from './point';\r\nimport { Color } from \"./color\";\r\n// //// Shaders\r\n// ------------------\r\nvar EYE_NORMAL = POINT_Z;\r\n// These shading functions compute the shading for a surface. To reduce code\r\n// duplication, we aggregate them in a utils object.\r\nvar ShaderUtils = /** @class */ (function () {\r\n    function ShaderUtils() {\r\n    }\r\n    ShaderUtils.applyDiffuse = function (c, light, lightNormal, surfaceNormal, material) {\r\n        var dot = lightNormal.dot(surfaceNormal);\r\n        if (dot > 0) {\r\n            // Apply diffuse phong shading\r\n            c.addChannels(light.colorIntensity.copy().scale(dot));\r\n        }\r\n    };\r\n    ShaderUtils.applyDiffuseAndSpecular = function (c, light, lightNormal, surfaceNormal, material) {\r\n        var dot = lightNormal.dot(surfaceNormal);\r\n        if (dot > 0) {\r\n            // Apply diffuse phong shading\r\n            c.addChannels(light.colorIntensity.copy().scale(dot));\r\n            // TODO  Error('dot is a number, not a V4 ?!?')\r\n            throw new Error('dot is a number, not a V4 ?!?');\r\n            // // Compute and apply specular phong shading\r\n            // let reflectionNormal = surfaceNormal.copy().multiply(dot * 2).subtract(lightNormal)\r\n            // let specularIntensity = Math.pow(0.5 + reflectionNormal.dot(EYE_NORMAL), material.specularExponent)\r\n            // let specularColor = material.specularColor.copy().scale(specularIntensity * light.intensity / 255.0)\r\n            // c.addChannels(specularColor)\r\n        }\r\n    };\r\n    ShaderUtils.applyAmbient = function (c, light) {\r\n        // Apply ambient shading\r\n        c.addChannels(light.colorIntensity);\r\n    };\r\n    return ShaderUtils;\r\n}());\r\n// The `Shader` class is the base class for all shader objects.\r\nvar Shader = /** @class */ (function () {\r\n    function Shader() {\r\n    }\r\n    /** Every `Shader` implementation must override the `shade` method.\r\n    \r\n    `lights` is an object containing the ambient, point, and directional light sources.\r\n    `renderGroup` is an instance of `RenderGroup` and contains the transformed and projected surface data.\r\n    `material` is an instance of `Material` and contains the color and other attributes for determining how light reflects off the surface.*/\r\n    Shader.prototype.shade = function (lights, renderGroup, material) {\r\n        return new Color();\r\n    };\r\n    return Shader;\r\n}());\r\nexport { Shader };\r\n// The `Phong` shader implements the Phong shading model with a diffuse,\r\n// specular, and ambient term.\r\n//\r\n// See https://en.wikipedia.org/wiki/Phong_reflection_model for more information\r\nvar Phong = /** @class */ (function (_super) {\r\n    __extends(Phong, _super);\r\n    function Phong() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Phong.prototype.shade = function (lights, renderGroup, material) {\r\n        var c = new Color();\r\n        lights.forEach(function (light) {\r\n            switch (light.type) {\r\n                case 'point':\r\n                    var lightNormal = light.point.copy().subtract(renderGroup.barycenter).normalize();\r\n                    ShaderUtils.applyDiffuseAndSpecular(c, light, lightNormal, renderGroup.normal, material);\r\n                    break;\r\n                case 'directional':\r\n                    ShaderUtils.applyDiffuseAndSpecular(c, light, light.normal, renderGroup.normal, material);\r\n                    break;\r\n                case 'ambient':\r\n                    ShaderUtils.applyAmbient(c, light);\r\n                    break;\r\n                default:\r\n                    console.assert(false, \"should never get here, light.type was \" + light.type);\r\n            }\r\n        });\r\n        c.multiplyChannels(material.color);\r\n        if (material.metallic) {\r\n            c.minChannels(material.specularColor);\r\n        }\r\n        c.clamp(0, 0xFF);\r\n        return c;\r\n    };\r\n    return Phong;\r\n}(Shader));\r\nexport { Phong };\r\n// The `DiffusePhong` shader implements the Phong shading model with a diffuse\r\n// and ambient term (no specular).\r\nvar DiffusePhong = /** @class */ (function (_super) {\r\n    __extends(DiffusePhong, _super);\r\n    function DiffusePhong() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DiffusePhong.prototype.shade = function (lights, renderGroup, material) {\r\n        var c = new Color();\r\n        lights.forEach(function (light) {\r\n            switch (light.type) {\r\n                case 'point':\r\n                    var lightNormal = light.point.copy().subtract(renderGroup.barycenter).normalize();\r\n                    ShaderUtils.applyDiffuse(c, light, lightNormal, renderGroup.normal, material);\r\n                case 'directional':\r\n                    ShaderUtils.applyDiffuse(c, light, light.normal, renderGroup.normal, material);\r\n                case 'ambient':\r\n                    ShaderUtils.applyAmbient(c, light);\r\n            }\r\n            c.multiplyChannels(material.color).clamp(0, 0xFF);\r\n        });\r\n        return c;\r\n    };\r\n    return DiffusePhong;\r\n}(Shader));\r\n// The `Ambient` shader colors surfaces from ambient light only.\r\nvar Ambient = /** @class */ (function (_super) {\r\n    __extends(Ambient, _super);\r\n    function Ambient() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Ambient.prototype.shade = function (lights, renderGroup, material) {\r\n        var c = new Color();\r\n        lights.forEach(function (light) {\r\n            switch (light.type) {\r\n                case 'ambient':\r\n                    ShaderUtils.applyAmbient(c, light);\r\n                    break;\r\n            }\r\n            c.multiplyChannels(material.color).clamp(0, 0xFF);\r\n        });\r\n        return c;\r\n    };\r\n    return Ambient;\r\n}(Shader));\r\n// The `Flat` shader colors surfaces with the material color, disregarding all\r\n// light sources.\r\nvar Flat = /** @class */ (function (_super) {\r\n    __extends(Flat, _super);\r\n    function Flat() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Flat.prototype.shade = function (lights, renderGroup, material) {\r\n        return material.color;\r\n    };\r\n    return Flat;\r\n}(Shader));\r\n// tom: this should be a type declaration to give the shaker a chance\r\nvar Shaders = /** @class */ (function () {\r\n    function Shaders() {\r\n    }\r\n    Shaders.phong = new Phong();\r\n    Shaders.diffuse = new DiffusePhong();\r\n    Shaders.ambient = new Ambient();\r\n    Shaders.flat = new Flat();\r\n    return Shaders;\r\n}());\r\nexport { Shaders };\r\n","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Transformable } from './transformable';\r\n// A `Shape` contains a collection of surface. They may create a closed 3D\r\n// shape, but not necessarily. For example, a cube is a closed shape, but a\r\n// patch is not.\r\nvar Shape = /** @class */ (function (_super) {\r\n    __extends(Shape, _super);\r\n    function Shape(type, surfaces) {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = type;\r\n        _this.surfaces = surfaces;\r\n        return _this;\r\n    }\r\n    Shape.prototype.recalculateSurfaces = function () {\r\n        var _this = this;\r\n        var surfaceList = [];\r\n        this.recalculateMatrix(); // this shape is a 'transformable' with one matrix\r\n        this.surfaces.forEach(function (surface) {\r\n            // apply the shape's m to that surface\r\n            // surface.points.map((p) => showPoint('points', p))\r\n            surface.transform(_this.m);\r\n            // surface.transformedPoints.map((p) => showPoint('transformedpoints', p))\r\n        });\r\n    };\r\n    Shape.prototype.visibleSurfaces = function (camera) {\r\n        var surfaceList = [];\r\n        this.surfaces.forEach(function (surface) {\r\n            // some filter here...\r\n            surfaceList.push(surface);\r\n        });\r\n        return (surfaceList);\r\n    };\r\n    /** Apply the supplied fill `Material` to each surface */\r\n    Shape.prototype.fill = function (fill) {\r\n        //    this.eachSurface (s) => { s.fill(fill)}\r\n        return this;\r\n    };\r\n    /** Apply the supplied stroke `Material` to each surface */\r\n    Shape.prototype.stroke = function (stroke) {\r\n        //    this.eachSurface (s) -> s.stroke(stroke)\r\n        return this;\r\n    };\r\n    return Shape;\r\n}(Transformable));\r\nexport { Shape };\r\nfunction showPoint(msg, p) {\r\n    console.log(msg + \" (\" + p.x + \",\" + p.y + \",\" + p.z + \",\" + p.w + \")\");\r\n}\r\n","//// Shapes\r\n// //////// Shape primitives and shape-making methods\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { P } from '../point';\r\nimport { Surface } from '../surface'; // TODO: rename Shape to Surface, Surface to Triangle\r\nimport { Shape } from '../shape';\r\n// Map to points in the surfaces of a tetrahedron\r\nvar TETRAHEDRON_COORDINATE_MAP = [\r\n    [0, 2, 1],\r\n    [0, 1, 3],\r\n    [3, 2, 0],\r\n    [1, 2, 3],\r\n];\r\n// triangles formed from points in TETRAHEDRON_COORDINATE_MAP\r\nvar TETRA_MAP = [\r\n    [0, 1, 2],\r\n    [0, 2, 3],\r\n    [0, 1, 3],\r\n    [1, 2, 3],\r\n];\r\n// // Map to points in the surfaces of a cube\r\n// const CUBE_COORDINATE_MAP = [\r\n//     [0, 1, 3, 2], // left\r\n//     [5, 4, 6, 7], // right\r\n//     [1, 0, 4, 5], // bottom\r\n//     [2, 3, 7, 6], // top\r\n//     [3, 1, 5, 7], // front\r\n//     [0, 2, 6, 4], // back\r\n// ]\r\n// TODO: Shapes should be part of the Shape() class  - box:Shape = new Shape().box()\r\n/** static methods to create `Shape` */\r\nvar Triangle = /** @class */ (function () {\r\n    function Triangle() {\r\n    }\r\n    return Triangle;\r\n}());\r\nexport { Triangle };\r\nvar Primitive = /** @class */ (function () {\r\n    function Primitive() {\r\n        this.triangles = [];\r\n    }\r\n    return Primitive;\r\n}());\r\nexport { Primitive };\r\n/** Sometimes we just want an empty `Group` that we can add children to */\r\nexport function NullShape() {\r\n    var points = [P(0, 0, 0), P(0, 0, 0), P(0, 0, 0)];\r\n    return new Shape('nullshape', mapPointsToSurfaces(points, []));\r\n}\r\n// a single right-angle triangle on the xy axis lines\r\nvar testTrianglePoints = [P(0, 0, 0), P(1, 0, 0), P(0, 1, 0)];\r\n// Map to points in the surfaces of a cube, two triangles to a side\r\nvar testTriangle_coordinate_map = [\r\n    [0, 1, 2],\r\n];\r\nvar TestTriangle = /** @class */ (function (_super) {\r\n    __extends(TestTriangle, _super);\r\n    function TestTriangle(options) {\r\n        return _super.call(this, 'testTriangle', mapPointsToSurfaces(testTrianglePoints, testTriangle_coordinate_map)) || this;\r\n    }\r\n    return TestTriangle;\r\n}(Shape));\r\nexport { TestTriangle };\r\nvar cubePoints = [P(-1, -1, -1), P(-1, -1, 1), P(-1, 1, -1), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];\r\n// Map to points in the surfaces of a cube, two triangles to a side\r\nvar CUBE_COORDINATE_MAP = [\r\n    [0, 1, 3],\r\n    [0, 3, 2],\r\n    [5, 4, 6],\r\n    [5, 6, 7],\r\n    [1, 0, 4],\r\n    [1, 4, 5],\r\n    [2, 3, 7],\r\n    [2, 7, 6],\r\n    [3, 1, 5],\r\n    [3, 5, 7],\r\n    [0, 2, 6],\r\n    [0, 6, 4],\r\n];\r\nvar Cube = /** @class */ (function (_super) {\r\n    __extends(Cube, _super);\r\n    function Cube(options) {\r\n        return _super.call(this, 'cube', mapPointsToSurfaces(cubePoints, CUBE_COORDINATE_MAP)) || this;\r\n    }\r\n    return Cube;\r\n}(Shape));\r\nexport { Cube };\r\nvar pyramidPoints = [P(0, 0, 0), P(0, 0, 1), P(1, 0, 0), P(1, 0, 1), P(0.5, 1, 0.5)];\r\n// Map to points in the surfaces of a rectangular pyramid\r\nvar PYRAMID_COORDINATE_MAP = [\r\n    [1, 0, 2, 3],\r\n    [0, 1, 4],\r\n    [2, 0, 4],\r\n    [3, 2, 4],\r\n    [1, 3, 4],\r\n];\r\nvar Pyramid = /** @class */ (function (_super) {\r\n    __extends(Pyramid, _super);\r\n    function Pyramid(options) {\r\n        return _super.call(this, 'pyramid', mapPointsToSurfaces(pyramidPoints, PYRAMID_COORDINATE_MAP)) || this;\r\n    }\r\n    return Pyramid;\r\n}(Shape));\r\nexport { Pyramid };\r\n// Map to points in the surfaces of an icosahedron\r\nvar ICOSAHEDRON_COORDINATE_MAP = [\r\n    [0, 4, 1],\r\n    [0, 9, 4],\r\n    [9, 5, 4],\r\n    [4, 5, 8],\r\n    [4, 8, 1],\r\n    [8, 10, 1],\r\n    [8, 3, 10],\r\n    [5, 3, 8],\r\n    [5, 2, 3],\r\n    [2, 7, 3],\r\n    [7, 10, 3],\r\n    [7, 6, 10],\r\n    [7, 11, 6],\r\n    [11, 0, 6],\r\n    [0, 1, 6],\r\n    [6, 1, 10],\r\n    [9, 0, 11],\r\n    [9, 11, 2],\r\n    [9, 2, 5],\r\n    [7, 2, 11],\r\n];\r\n// Altitude of eqiulateral triangle for computing triangular patch size\r\nvar EQUILATERAL_TRIANGLE_ALTITUDE = Math.sqrt(3.0) / 2.0;\r\n// Points array of an icosahedron\r\nvar ICOS_X = 0.525731112119133606;\r\nvar ICOS_Z = 0.850650808352039932;\r\nvar ICOSAHEDRON_POINTS = [\r\n    P(-ICOS_X, 0.0, -ICOS_Z),\r\n    P(ICOS_X, 0.0, -ICOS_Z),\r\n    P(-ICOS_X, 0.0, ICOS_Z),\r\n    P(ICOS_X, 0.0, ICOS_Z),\r\n    P(0.0, ICOS_Z, -ICOS_X),\r\n    P(0.0, ICOS_Z, ICOS_X),\r\n    P(0.0, -ICOS_Z, -ICOS_X),\r\n    P(0.0, -ICOS_Z, ICOS_X),\r\n    P(ICOS_Z, ICOS_X, 0.0),\r\n    P(-ICOS_Z, ICOS_X, 0.0),\r\n    P(ICOS_Z, -ICOS_X, 0.0),\r\n    P(-ICOS_Z, -ICOS_X, 0.0),\r\n];\r\nvar Icosahedron = /** @class */ (function (_super) {\r\n    __extends(Icosahedron, _super);\r\n    function Icosahedron(options) {\r\n        return _super.call(this, 'icosahedron', mapPointsToSurfaces(ICOSAHEDRON_POINTS, ICOSAHEDRON_COORDINATE_MAP)) || this;\r\n    }\r\n    return Icosahedron;\r\n}(Shape));\r\nexport { Icosahedron };\r\n//   unitcube() {\r\n//   let points = [P(0, 0, 0), P(0, 0, 1), P(0, 1, 0), P(0, 1, 1), P(1, 0, 0), P(1, 0, 1), P(1, 1, 0), P(1, 1, 1)];\r\n//   return new Shape('unitcube', this.mapPointsToSurfaces( points, CUBE_COORDINATE_MAP ));\r\n// }\r\n//   rectangle: (function (_this) {\r\n//     return function (point1, point2) {\r\n//       var compose, points;\r\n//       compose = function (x, y, z) {\r\n//         return P(x(point1.x, point2.x), y(point1.y, point2.y), z(point1.z, point2.z));\r\n//       };\r\n//       points = [compose(Math.min, Math.min, Math.min), compose(Math.min, Math.min, Math.max), compose(Math.min, Math.max, Math.min), compose(Math.min, Math.max, Math.max), compose(Math.max, Math.min, Math.min), compose(Math.max, Math.min, Math.max), compose(Math.max, Math.max, Math.min), compose(Math.max, Math.max, Math.max)];\r\n//       return new Shape('rect', Shapes.mapPointsToSurfaces(points, CUBE_COORDINATE_MAP));\r\n//     };\r\n//   })(this),\r\n//   tetrahedron: (function (_this) {\r\n//     return function () {\r\n//       var points;\r\n//       points = [P(1, 1, 1), P(-1, -1, 1), P(-1, 1, -1), P(1, -1, -1)];\r\n//       return new Shape('tetrahedron', Shapes.mapPointsToSurfaces(points, TETRAHEDRON_COORDINATE_MAP));\r\n//     };\r\n//   })(this),\r\n//   sphere: function (subdivisions) {\r\n//     var i, j, ref, triangles;\r\n//     if (subdivisions == null) {\r\n//       subdivisions = 2;\r\n//     }\r\n//     triangles = ICOSAHEDRON_COORDINATE_MAP.map(function (coords) {\r\n//       return coords.map(function (c) {\r\n//         return ICOSAHEDRON_POINTS[c];\r\n//       });\r\n//     });\r\n//     for (i = j = 0, ref = subdivisions; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\r\n//       triangles = Shapes._subdivideTriangles(triangles);\r\n//     }\r\n//     return new Shape('sphere', triangles.map(function (triangle) {\r\n//       return new Surface(triangle.map(function (v) {\r\n//         return v.copy();\r\n//       }));\r\n//     }));\r\n//   },\r\n//   pipe: function (point1, point2, radius, segments) {\r\n//     var axis, j, perp, points, quat, results, theta;\r\n//     if (radius == null) {\r\n//       radius = 1;\r\n//     }\r\n//     if (segments == null) {\r\n//       segments = 8;\r\n//     }\r\n//     axis = point2.copy().subtract(point1);\r\n//     perp = axis.perpendicular().multiply(radius);\r\n//     theta = -Math.PI * 2.0 / segments;\r\n//     quat = Quaternion.pointAngle(axis.copy().normalize(), theta).toMatrix();\r\n//     points = (function () {\r\n//       results = [];\r\n//       for (var j = 0; 0 <= segments ? j < segments : j > segments; 0 <= segments ? j++ : j--) { results.push(j); }\r\n//       return results;\r\n//     }).apply(this).map(function (i) {\r\n//       var p;\r\n//       p = point1.copy().add(perp);\r\n//       perp.transform(quat);\r\n//       return p;\r\n//     });\r\n//     return Shapes.extrude(points, axis);\r\n//   },\r\n//   patch: function (nx, ny) {\r\n//     var column, j, k, l, len1, len2, len3, m, n, p, pts, pts0, pts1, ref, ref1, ref2, ref3, surfaces, x, y;\r\n//     if (nx == null) {\r\n//       nx = 20;\r\n//     }\r\n//     if (ny == null) {\r\n//       ny = 20;\r\n//     }\r\n//     nx = Math.round(nx);\r\n//     ny = Math.round(ny);\r\n//     surfaces = [];\r\n//     for (x = j = 0, ref = nx; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {\r\n//       column = [];\r\n//       for (y = k = 0, ref1 = ny; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {\r\n//         pts0 = [P(x, y), P(x + 1, y - 0.5), P(x + 1, y + 0.5)];\r\n//         pts1 = [P(x, y), P(x + 1, y + 0.5), P(x, y + 1)];\r\n//         ref2 = [pts0, pts1];\r\n//         for (l = 0, len1 = ref2.length; l < len1; l++) {\r\n//           pts = ref2[l];\r\n//           for (m = 0, len2 = pts.length; m < len2; m++) {\r\n//             p = pts[m];\r\n//             p.x *= EQUILATERAL_TRIANGLE_ALTITUDE;\r\n//             p.y += x % 2 === 0 ? 0.5 : 0;\r\n//           }\r\n//           column.push(pts);\r\n//         }\r\n//       }\r\n//       if (x % 2 !== 0) {\r\n//         ref3 = column[0];\r\n//         for (n = 0, len3 = ref3.length; n < len3; n++) {\r\n//           p = ref3[n];\r\n//           p.y += ny;\r\n//         }\r\n//         column.push(column.shift());\r\n//       }\r\n//       surfaces = surfaces.concat(column);\r\n//     }\r\n//     return new Shape('patch', surfaces.map(function (s) {\r\n//       return new Surface(s);\r\n//     }));\r\n//   },\r\n//   text: function (text, surfaceOptions) {\r\n//     var key, surface, val;\r\n//     if (surfaceOptions == null) {\r\n//       surfaceOptions = {};\r\n//     }\r\n//     surface = new Surface(Affine.ORTHONORMAL_BASIS(), Painters.text);\r\n//     surface.text = text;\r\n//     for (key in surfaceOptions) {\r\n//       val = surfaceOptions[key];\r\n//       surface[key] = val;\r\n//     }\r\n//     return new Shape('text', [surface]);\r\n//   },\r\n//   extrude: function (points, offset) {\r\n//     var back, front, i, j, len, p, ref, surfaces;\r\n//     surfaces = [];\r\n//     front = new Surface((function () {\r\n//       var j, len1, results;\r\n//       results = [];\r\n//       for (j = 0, len1 = points.length; j < len1; j++) {\r\n//         p = points[j];\r\n//         results.push(p.copy());\r\n//       }\r\n//       return results;\r\n//     })());\r\n//     back = new Surface((function () {\r\n//       var j, len1, results;\r\n//       results = [];\r\n//       for (j = 0, len1 = points.length; j < len1; j++) {\r\n//         p = points[j];\r\n//         results.push(p.add(offset));\r\n//       }\r\n//       return results;\r\n//     })());\r\n//     for (i = j = 1, ref = points.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\r\n//       surfaces.push(new Surface([front.points[i - 1].copy(), back.points[i - 1].copy(), back.points[i].copy(), front.points[i].copy()]));\r\n//     }\r\n//     len = points.length;\r\n//     surfaces.push(new Surface([front.points[len - 1].copy(), back.points[len - 1].copy(), back.points[0].copy(), front.points[0].copy()]));\r\n//     back.points.reverse();\r\n//     surfaces.push(front);\r\n//     surfaces.push(back);\r\n//     return new Shape('extrusion', surfaces);\r\n//   },\r\n//   arrow: function (thickness, tailLength, tailWidth, headLength, headPointiness) {\r\n//     var htw, points;\r\n//     if (thickness == null) {\r\n//       thickness = 1;\r\n//     }\r\n//     if (tailLength == null) {\r\n//       tailLength = 1;\r\n//     }\r\n//     if (tailWidth == null) {\r\n//       tailWidth = 1;\r\n//     }\r\n//     if (headLength == null) {\r\n//       headLength = 1;\r\n//     }\r\n//     if (headPointiness == null) {\r\n//       headPointiness = 0;\r\n//     }\r\n//     htw = tailWidth / 2;\r\n//     points = [P(0, 0, 0), P(headLength + headPointiness, 1, 0), P(headLength, htw, 0), P(headLength + tailLength, htw, 0), P(headLength + tailLength, -htw, 0), P(headLength, -htw, 0), P(headLength + headPointiness, -1, 0)];\r\n//     return Shapes.extrude(points, P(0, 0, thickness));\r\n//   },\r\n//   path: function (points) {\r\n//     return new Shape('path', [new Surface(points)]);\r\n//   },\r\n//   custom: function (s) {\r\n//     var f, j, len1, p, ref, surfaces;\r\n//     surfaces = [];\r\n//     ref = s.surfaces;\r\n//     for (j = 0, len1 = ref.length; j < len1; j++) {\r\n//       f = ref[j];\r\n//       surfaces.push(new Surface((function () {\r\n//         var k, len2, results;\r\n//         results = [];\r\n//         for (k = 0, len2 = f.length; k < len2; k++) {\r\n//           p = f[k];\r\n//           results.push(P.apply(seen, p));\r\n//         }\r\n//         return results;\r\n//       })()));\r\n//     }\r\n//     return new Shape('custom', surfaces);\r\n//   },\r\n/** points[] are the vertexes of the shape (indexed from zero),\r\n * coordinateMap[] are sets of vertex indexes that form exterior triangles or quads\r\n * we return an array of `Surface` objects (triangles) ready to transform  */\r\nfunction mapPointsToSurfaces(points, coordinateMap) {\r\n    // TODO: convert all exterior quads to triangles  (eg: two triangles per side for a cube)\r\n    var s = [];\r\n    points.forEach(function (point) {\r\n        console.log('POINTS', point);\r\n    });\r\n    coordinateMap.forEach(function (element) {\r\n        console.log('ELEMENT', element);\r\n        s.push(new Surface('triangle', points[element[0]], points[element[1]], points[element[2]]));\r\n    });\r\n    return s;\r\n}\r\n//   _subdivideTriangles: function (triangles) {\r\n//     var j, len1, newTriangles, tri, v01, v12, v20;\r\n//     newTriangles = [];\r\n//     for (j = 0, len1 = triangles.length; j < len1; j++) {\r\n//       tri = triangles[j];\r\n//       v01 = tri[0].copy().add(tri[1]).normalize();\r\n//       v12 = tri[1].copy().add(tri[2]).normalize();\r\n//       v20 = tri[2].copy().add(tri[0]).normalize();\r\n//       newTriangles.push([tri[0], v01, v20]);\r\n//       newTriangles.push([tri[1], v12, v01]);\r\n//       newTriangles.push([tri[2], v20, v12]);\r\n//       newTriangles.push([v01, v12, v20]);\r\n//     }\r\n//     return newTriangles;\r\n//   }\r\n// };\r\n","// //// Surfaces and Shapes\r\n// ------------------\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// import { Point, P } from './point'\r\nimport { Util } from './util';\r\nimport { Material } from './materials';\r\nimport { Transformable, } from './transformable';\r\nimport { V4 } from './vectorMath';\r\n// A `Surface` is a defined as a planar object in 3D space. These paths don't\r\n// necessarily need to be convex, but they should be non-degenerate. This\r\n// library does not support shapes with holes.\r\n// TODO: rename 'Surface' to 'Triangle' and fix up the code\r\nvar Surface = /** @class */ (function (_super) {\r\n    __extends(Surface, _super);\r\n    function Surface(stype, p1, p2, p3, p4) {\r\n        var _this = _super.call(this) || this;\r\n        // the centroid (sometimes called 'barycenter') is the \r\n        // geometric center of all points in the triangle.  \r\n        _this.centroid = new V4();\r\n        _this.transformedCentroid = new V4();\r\n        // When 'false' this will override backface culling, which is useful if your\r\n        // material is transparent. See comment in `Scene`.\r\n        _this.cullBackfaces = true;\r\n        // Fill and stroke may be `Material` objects, which define the color and\r\n        // finish of the object and are rendered using the scene's shader.\r\n        _this.fillMaterial = new Material('gray');\r\n        _this.strokeMaterial = null;\r\n        _this.dirty = false;\r\n        _this.points = [p1, p2, p3];\r\n        // We store a unique id for every surface so we can look them up quickly\r\n        // with the `renderGroup` cache.\r\n        _this.id = 's' + Util.uniqueId();\r\n        //this.painter = painter\r\n        // calculate the centroid, but do NOT normalize it\r\n        _this.centroid.x = (_this.points[0].x + _this.points[1].x + _this.points[2].x) / 3;\r\n        _this.centroid.y = (_this.points[0].y + _this.points[1].y + _this.points[2].y) / 3;\r\n        _this.centroid.z = (_this.points[0].z + _this.points[1].z + _this.points[2].z) / 3;\r\n        _this.fillMaterial = new Material('gray');\r\n        _this.strokeMaterial = new Material('blue');\r\n        return _this;\r\n    }\r\n    /** shift this surface using m, recalculate normals, etc */\r\n    Surface.prototype.transform = function (m) {\r\n        this.transformedPoints = this.points.map(function (point) {\r\n            return (point.copy().multiplyMat4(m));\r\n        });\r\n        // calculate the centroid, but do NOT normalize it\r\n        this.transformedCentroid.x = (this.transformedPoints[0].x + this.transformedPoints[1].x + this.transformedPoints[2].x) / 3;\r\n        this.transformedCentroid.y = (this.transformedPoints[0].y + this.transformedPoints[1].y + this.transformedPoints[2].y) / 3;\r\n        this.transformedCentroid.z = (this.transformedPoints[0].z + this.transformedPoints[1].z + this.transformedPoints[2].z) / 3;\r\n        // this.transformedCentroid = this.centroid.copy().multiplyMat4(m)\r\n        console.log('centroid', this.centroid, this.transformedCentroid);\r\n    };\r\n    Surface.prototype.render = function (canvas) {\r\n        // draw the triangle outline in blue\r\n        canvas.ctx.beginPath(); // Start a new path.\r\n        canvas.ctx.lineWidth = 1;\r\n        canvas.ctx.strokeStyle = \"blue\"; // This path is green.\r\n        canvas.ctx.moveTo(this.transformedPoints[0].x, this.transformedPoints[0].y);\r\n        canvas.ctx.lineTo(this.transformedPoints[1].x, this.transformedPoints[1].y);\r\n        canvas.ctx.lineTo(this.transformedPoints[2].x, this.transformedPoints[2].y);\r\n        canvas.ctx.closePath();\r\n        canvas.ctx.stroke();\r\n        canvas.ctx.fillStyle = 'green';\r\n        canvas.ctx.fillRect(this.transformedCentroid.x, this.transformedCentroid.y, 5, 5); // fill in the pixel at (10,10)\r\n        // canvas.draw(this.strokeMaterial)\r\n        // canvas.ctx.lineWidth = 3\r\n        // canvas.ctx.strokeStyle = \"gray\"\r\n        // canvas.path(this.transformedPoints)\r\n        // canvas.ctx.closePath()\r\n    };\r\n    Surface.prototype.fill = function (fill) {\r\n        this.fillMaterial = new Material('gray').create(fill);\r\n        return this;\r\n    };\r\n    Surface.prototype.stroke = function (stroke) {\r\n        this.strokeMaterial = new Material('gray').create(stroke);\r\n        return this;\r\n    };\r\n    return Surface;\r\n}(Transformable));\r\nexport { Surface };\r\n","import { V3, M4 } from './vectorMath';\r\n// `Transformable` base class extended by `Shape` and `Group`.\r\n//\r\n// It stores transformations in the scene. These include:\r\n// (1) Camera Projection and Viewport transformations.\r\n// (2) Transformations of any `Transformable` type object\r\n//\r\n// Underneath, it's just matrix arithmetic.  When you use\r\n// a matrix object in this library, they are really\r\n// instances of 'Transformable'\r\n// A convenience method for constructing Matrix objects.\r\nexport function M(m) {\r\n    console.assert(m.length === 16, 'array for M() was not length 16');\r\n    return (new M4(m));\r\n}\r\n// Most of the matrix methods are destructive, so be sure to use `.copy()`\r\n// when you want to preserve an object's value.\r\n// All `Transformable` objects get matrix-transformation methods like\r\n//  'scale', 'translate', 'rotx', 'roty', 'rotz', 'matrix', 'reset', 'bake'\r\n//\r\n// The advantages of keeping transforms in `Matrix` form are\r\n// (1) lazy computation of point position\r\n// (2) ability combine hierarchical transformations easily\r\n// (3) ability to reset transformations to an original state.\r\n//\r\n// Resetting transformations is especially useful when you want to animate\r\n// interpolated values. Instead of computing the difference at each animation\r\n// step, you can compute the global interpolated value for that time step and\r\n// apply that value directly to a matrix (once it is reset).\r\nexport var IDENTITY = [1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1];\r\n// Groups and Shapes are decendents of 'transformable', a single matrix\r\n// determines their scale, rotation, and translation     \r\n// Cameras and Lights are also transformables, but this doesn't totally make \r\n// sense since they can't be scaled.\r\nvar Transformable = /** @class */ (function () {\r\n    function Transformable() {\r\n        this.m = new M4(IDENTITY); // shallow copy\r\n        this._rotation = new V3([1, 1, 1]); // really three angles\r\n        this._scale = new V3([1, 1, 1]);\r\n        this._position = new V3([1, 1, 1]);\r\n    }\r\n    Object.defineProperty(Transformable.prototype, \"rotation\", {\r\n        ///////////////////////\r\n        // define get and set for rotation, scale, position\r\n        get: function () {\r\n            return this._rotation;\r\n        },\r\n        set: function (r) {\r\n            this._rotation = r;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Transformable.prototype, \"scale\", {\r\n        get: function () {\r\n            return this._scale;\r\n        },\r\n        set: function (r) {\r\n            this._scale = r;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Transformable.prototype, \"position\", {\r\n        get: function () {\r\n            return this._position;\r\n        },\r\n        set: function (r) {\r\n            this._position = r;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Transformable.prototype.recalculateMatrix = function () {\r\n        this.m = new M4()\r\n            .scale(this._scale)\r\n            .translate(this._position)\r\n            .rotate(this._rotation.x, new V3([1, 0, 0]))\r\n            .rotate(this._rotation.y, new V3([0, 1, 0]))\r\n            .rotate(this._rotation.z, new V3([0, 0, 1]));\r\n        // console.log('recalculate', this.m)\r\n    };\r\n    return Transformable;\r\n}());\r\nexport { Transformable };\r\n","// //// Util\r\n// //////// Utility methods\r\n// ------------------\r\nvar NEXT_UNIQUE_ID = 1; // An auto-incremented value\r\nvar Util = /** @class */ (function () {\r\n    function Util() {\r\n    }\r\n    // Copies default values. First, overwrite undefined attributes of `obj` from\r\n    // `opts`. Second, overwrite undefined attributes of `obj` from `defaults`.\r\n    Util.defaults = function (obj, opts, defaults) {\r\n        var prop, results;\r\n        for (prop in opts) {\r\n            if (obj[prop] == null) {\r\n                obj[prop] = opts[prop];\r\n            }\r\n        }\r\n        results = [];\r\n        for (prop in defaults) {\r\n            if (obj[prop] == null) {\r\n                results.push(obj[prop] = defaults[prop]);\r\n            }\r\n            else {\r\n                results.push(void 0);\r\n            }\r\n        }\r\n        return results;\r\n    };\r\n    /** Returns an ID which is unique to this instance of the library */ // TODO: change to type 'symbol'?\r\n    Util.uniqueId = function (prefix) {\r\n        if (prefix === void 0) { prefix = 'x'; }\r\n        return (prefix + NEXT_UNIQUE_ID++);\r\n    };\r\n    // Accept a DOM element or a string. If a string is provided, we assume it is\r\n    // the id of an element, which we return.\r\n    Util.element = function (elementOrString) {\r\n        if (typeof elementOrString === 'string') {\r\n            return document.getElementById(elementOrString);\r\n        }\r\n        else {\r\n            return elementOrString;\r\n        }\r\n    };\r\n    return Util;\r\n}());\r\nexport { Util };\r\n","/*********************\r\n * see:  https://github.com/matthiasferch/tsm\r\n *\r\n * V2\r\n * v3\r\n * V4\r\n * M2\r\n * M3\r\n * M4\r\n * quat\r\n *\r\n */\r\n/* This version of TSM was lightly modified by Tom Berend from the original of Matthias Ferch,\r\n * whose copyright notice follows below.\r\n *\r\n *  - The names of the functions were changed (eg: vec3 -> V3).\r\n *  - A 'modified' flag added to V3\r\n *  - Added a V4.dot() scaler method\r\n *  - The default M4 matrix is Identity, not Zero.\r\n *  - Combined into a single file to eliminate circular dependencies\r\n *  - Code was converted to newer TypeScript\r\n *  - Several small type errors were fixed (TypeScript found them)\r\n *  - A few inconsequential additions like 'Quat.zero'\r\n *\r\n */\r\n/*\r\n * Copyright (c) 2012, 2018 Matthias Ferch\r\n *\r\n * Project homepage: https://github.com/matthiasferch/tsm\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty. In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n *\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n *\r\n *    1. The origin of this software must not be misrepresented; you must not\r\n *    claim that you wrote the original software. If you use this software\r\n *    in a product, an acknowledgment in the product documentation would be\r\n *    appreciated but is not required.\r\n *\r\n *    2. Altered source versions must be plainly marked as such, and must not\r\n *    be misrepresented as being the original software.\r\n *\r\n *    3. This notice may not be removed or altered from any source\r\n *    distribution.\r\n */\r\nvar epsilon = 0.00001;\r\nvar V2 = /** @class */ (function () {\r\n    function V2(values) {\r\n        this.values = new Float32Array(2);\r\n        if (values !== undefined) {\r\n            this.xy = values;\r\n        }\r\n    }\r\n    Object.defineProperty(V2.prototype, \"x\", {\r\n        // a v2 is an array [x , y]\r\n        get: function () {\r\n            return this.values[0];\r\n        },\r\n        set: function (value) {\r\n            this.values[0] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V2.prototype, \"y\", {\r\n        get: function () {\r\n            return this.values[1];\r\n        },\r\n        set: function (value) {\r\n            this.values[1] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V2.prototype, \"xy\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    V2.cross = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var x2 = vector2.x;\r\n        var y2 = vector2.y;\r\n        var z = x * y2 - y * x2;\r\n        dest.x = 0;\r\n        dest.y = 0;\r\n        dest.z = z;\r\n        return dest;\r\n    };\r\n    V2.dot = function (vector, vector2) {\r\n        return (vector.x * vector2.x + vector.y * vector2.y);\r\n    };\r\n    V2.distance = function (vector, vector2) {\r\n        return Math.sqrt(this.squaredDistance(vector, vector2));\r\n    };\r\n    V2.squaredDistance = function (vector, vector2) {\r\n        var x = vector2.x - vector.x;\r\n        var y = vector2.y - vector.y;\r\n        return (x * x + y * y);\r\n    };\r\n    V2.direction = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        var x = vector.x - vector2.x;\r\n        var y = vector.y - vector2.y;\r\n        var length = Math.sqrt(x * x + y * y);\r\n        if (length === 0) {\r\n            dest.x = 0;\r\n            dest.y = 0;\r\n            return dest;\r\n        }\r\n        length = 1 / length;\r\n        dest.x = x * length;\r\n        dest.y = y * length;\r\n        return dest;\r\n    };\r\n    V2.mix = function (vector, vector2, time, dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var x2 = vector2.x;\r\n        var y2 = vector2.y;\r\n        dest.x = x + time * (x2 - x);\r\n        dest.y = y + time * (y2 - y);\r\n        return dest;\r\n    };\r\n    V2.sum = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        dest.x = vector.x + vector2.x;\r\n        dest.y = vector.y + vector2.y;\r\n        return dest;\r\n    };\r\n    V2.difference = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        dest.x = vector.x - vector2.x;\r\n        dest.y = vector.y - vector2.y;\r\n        return dest;\r\n    };\r\n    V2.product = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        dest.x = vector.x * vector2.x;\r\n        dest.y = vector.y * vector2.y;\r\n        return dest;\r\n    };\r\n    V2.quotient = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        dest.x = vector.x / vector2.x;\r\n        dest.y = vector.y / vector2.y;\r\n        return dest;\r\n    };\r\n    V2.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    V2.prototype.reset = function () {\r\n        this.x = 0;\r\n        this.y = 0;\r\n    };\r\n    V2.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new V2();\r\n        }\r\n        dest.x = this.x;\r\n        dest.y = this.y;\r\n        return dest;\r\n    };\r\n    V2.prototype.negate = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        dest.x = -this.x;\r\n        dest.y = -this.y;\r\n        return dest;\r\n    };\r\n    V2.prototype.equals = function (vector, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        if (Math.abs(this.x - vector.x) > threshold) {\r\n            return false;\r\n        }\r\n        if (Math.abs(this.y - vector.y) > threshold) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    V2.prototype.length = function () {\r\n        return Math.sqrt(this.squaredLength());\r\n    };\r\n    V2.prototype.squaredLength = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        return (x * x + y * y);\r\n    };\r\n    V2.prototype.add = function (vector) {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n        return this;\r\n    };\r\n    V2.prototype.subtract = function (vector) {\r\n        this.x -= vector.x;\r\n        this.y -= vector.y;\r\n        return this;\r\n    };\r\n    V2.prototype.multiply = function (vector) {\r\n        this.x *= vector.x;\r\n        this.y *= vector.y;\r\n        return this;\r\n    };\r\n    V2.prototype.divide = function (vector) {\r\n        this.x /= vector.x;\r\n        this.y /= vector.y;\r\n        return this;\r\n    };\r\n    V2.prototype.scale = function (value, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        dest.x *= value;\r\n        dest.y *= value;\r\n        return dest;\r\n    };\r\n    V2.prototype.normalize = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        var length = this.length();\r\n        if (length === 1) {\r\n            return this;\r\n        }\r\n        if (length === 0) {\r\n            dest.x = 0;\r\n            dest.y = 0;\r\n            return dest;\r\n        }\r\n        length = 1.0 / length;\r\n        dest.x *= length;\r\n        dest.y *= length;\r\n        return dest;\r\n    };\r\n    V2.prototype.multiplyMat2 = function (matrix, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        return matrix.multiplyVec2(this, dest);\r\n    };\r\n    V2.prototype.multiplyMat3 = function (matrix, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        return matrix.multiplyVec2(this, dest);\r\n    };\r\n    V2.zero = new V2([0, 0]);\r\n    V2.one = new V2([1, 1]);\r\n    return V2;\r\n}());\r\nexport { V2 };\r\nvar V3 = /** @class */ (function () {\r\n    function V3(values) {\r\n        this.values = new Float32Array(3);\r\n        this.modified = false;\r\n        if (values !== undefined) {\r\n            this.xyz = values;\r\n        }\r\n    }\r\n    Object.defineProperty(V3.prototype, \"x\", {\r\n        get: function () {\r\n            return this.values[0];\r\n        },\r\n        set: function (value) {\r\n            this.values[0] = value;\r\n            this.modified = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V3.prototype, \"y\", {\r\n        get: function () {\r\n            return this.values[1];\r\n        },\r\n        set: function (value) {\r\n            this.values[1] = value;\r\n            this.modified = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V3.prototype, \"z\", {\r\n        get: function () {\r\n            return this.values[2];\r\n        },\r\n        set: function (value) {\r\n            this.values[2] = value;\r\n            this.modified = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V3.prototype, \"xy\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.modified = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V3.prototype, \"xyz\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n            this.modified = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    V3.cross = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        var x2 = vector2.x;\r\n        var y2 = vector2.y;\r\n        var z2 = vector2.z;\r\n        dest.x = y * z2 - z * y2;\r\n        dest.y = z * x2 - x * z2;\r\n        dest.z = x * y2 - y * x2;\r\n        return dest;\r\n    };\r\n    V3.dot = function (vector, vector2) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        var x2 = vector2.x;\r\n        var y2 = vector2.y;\r\n        var z2 = vector2.z;\r\n        return (x * x2 + y * y2 + z * z2);\r\n    };\r\n    V3.distance = function (vector, vector2) {\r\n        var x = vector2.x - vector.x;\r\n        var y = vector2.y - vector.y;\r\n        var z = vector2.z - vector.z;\r\n        return Math.sqrt(this.squaredDistance(vector, vector2));\r\n    };\r\n    V3.squaredDistance = function (vector, vector2) {\r\n        var x = vector2.x - vector.x;\r\n        var y = vector2.y - vector.y;\r\n        var z = vector2.z - vector.z;\r\n        return (x * x + y * y + z * z);\r\n    };\r\n    V3.direction = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        var x = vector.x - vector2.x;\r\n        var y = vector.y - vector2.y;\r\n        var z = vector.z - vector2.z;\r\n        var length = Math.sqrt(x * x + y * y + z * z);\r\n        if (length === 0) {\r\n            dest.x = 0;\r\n            dest.y = 0;\r\n            dest.z = 0;\r\n            return dest;\r\n        }\r\n        length = 1 / length;\r\n        dest.x = x * length;\r\n        dest.y = y * length;\r\n        dest.z = z * length;\r\n        return dest;\r\n    };\r\n    V3.mix = function (vector, vector2, time, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        dest.x = vector.x + time * (vector2.x - vector.x);\r\n        dest.y = vector.y + time * (vector2.y - vector.y);\r\n        dest.z = vector.z + time * (vector2.z - vector.z);\r\n        return dest;\r\n    };\r\n    V3.sum = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        dest.x = vector.x + vector2.x;\r\n        dest.y = vector.y + vector2.y;\r\n        dest.z = vector.z + vector2.z;\r\n        return dest;\r\n    };\r\n    V3.difference = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        dest.x = vector.x - vector2.x;\r\n        dest.y = vector.y - vector2.y;\r\n        dest.z = vector.z - vector2.z;\r\n        return dest;\r\n    };\r\n    V3.product = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        dest.x = vector.x * vector2.x;\r\n        dest.y = vector.y * vector2.y;\r\n        dest.z = vector.z * vector2.z;\r\n        return dest;\r\n    };\r\n    V3.quotient = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        dest.x = vector.x / vector2.x;\r\n        dest.y = vector.y / vector2.y;\r\n        dest.z = vector.z / vector2.z;\r\n        return dest;\r\n    };\r\n    V3.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    V3.prototype.reset = function () {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n    };\r\n    V3.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        dest.x = this.x;\r\n        dest.y = this.y;\r\n        dest.z = this.z;\r\n        return dest;\r\n    };\r\n    V3.prototype.negate = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        dest.x = -this.x;\r\n        dest.y = -this.y;\r\n        dest.z = -this.z;\r\n        return dest;\r\n    };\r\n    V3.prototype.equals = function (vector, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        if (Math.abs(this.x - vector.x) > threshold) {\r\n            return false;\r\n        }\r\n        if (Math.abs(this.y - vector.y) > threshold) {\r\n            return false;\r\n        }\r\n        if (Math.abs(this.z - vector.z) > threshold) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    V3.prototype.length = function () {\r\n        return Math.sqrt(this.squaredLength());\r\n    };\r\n    V3.prototype.squaredLength = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        return (x * x + y * y + z * z);\r\n    };\r\n    V3.prototype.add = function (vector) {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n        this.z += vector.z;\r\n        return this;\r\n    };\r\n    V3.prototype.subtract = function (vector) {\r\n        this.x -= vector.x;\r\n        this.y -= vector.y;\r\n        this.z -= vector.z;\r\n        return this;\r\n    };\r\n    V3.prototype.multiply = function (vector) {\r\n        this.x *= vector.x;\r\n        this.y *= vector.y;\r\n        this.z *= vector.z;\r\n        return this;\r\n    };\r\n    V3.prototype.divide = function (vector) {\r\n        this.x /= vector.x;\r\n        this.y /= vector.y;\r\n        this.z /= vector.z;\r\n        return this;\r\n    };\r\n    V3.prototype.scale = function (value, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        dest.x *= value;\r\n        dest.y *= value;\r\n        dest.z *= value;\r\n        return dest;\r\n    };\r\n    V3.prototype.normalize = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        var length = this.length();\r\n        if (length === 1) {\r\n            return this;\r\n        }\r\n        if (length === 0) {\r\n            dest.x = 0;\r\n            dest.y = 0;\r\n            dest.z = 0;\r\n            return dest;\r\n        }\r\n        length = 1.0 / length;\r\n        dest.x *= length;\r\n        dest.y *= length;\r\n        dest.z *= length;\r\n        return dest;\r\n    };\r\n    V3.prototype.multiplyByMat3 = function (matrix, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        return matrix.multiplyVec3(this, dest);\r\n    };\r\n    V3.prototype.multiplyByQuat = function (quaternion, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        return quaternion.multiplyVec3(this, dest);\r\n    };\r\n    V3.prototype.toQuat = function (dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        var c = new V3();\r\n        var s = new V3();\r\n        c.x = Math.cos(this.x * 0.5);\r\n        s.x = Math.sin(this.x * 0.5);\r\n        c.y = Math.cos(this.y * 0.5);\r\n        s.y = Math.sin(this.y * 0.5);\r\n        c.z = Math.cos(this.z * 0.5);\r\n        s.z = Math.sin(this.z * 0.5);\r\n        dest.x = s.x * c.y * c.z - c.x * s.y * s.z;\r\n        dest.y = c.x * s.y * c.z + s.x * c.y * s.z;\r\n        dest.z = c.x * c.y * s.z - s.x * s.y * c.z;\r\n        dest.w = c.x * c.y * c.z + s.x * s.y * s.z;\r\n        return dest;\r\n    };\r\n    V3.zero = new V3([0, 0, 0]);\r\n    V3.one = new V3([1, 1, 1]);\r\n    V3.up = new V3([0, 1, 0]);\r\n    V3.right = new V3([1, 0, 0]);\r\n    V3.forward = new V3([0, 0, 1]);\r\n    return V3;\r\n}());\r\nexport { V3 };\r\nvar V4 = /** @class */ (function () {\r\n    function V4(values) {\r\n        this.values = new Float32Array(4);\r\n        if (values !== undefined) {\r\n            this.xyzw = values;\r\n        }\r\n    }\r\n    Object.defineProperty(V4.prototype, \"x\", {\r\n        get: function () {\r\n            return this.values[0];\r\n        },\r\n        set: function (value) {\r\n            this.values[0] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"y\", {\r\n        get: function () {\r\n            return this.values[1];\r\n        },\r\n        set: function (value) {\r\n            this.values[1] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"z\", {\r\n        get: function () {\r\n            return this.values[2];\r\n        },\r\n        set: function (value) {\r\n            this.values[2] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"w\", {\r\n        get: function () {\r\n            return this.values[3];\r\n        },\r\n        set: function (value) {\r\n            this.values[3] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"xy\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"xyz\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"xyzw\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n                this.values[3],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n            this.values[3] = values[3];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"r\", {\r\n        get: function () {\r\n            return this.values[0];\r\n        },\r\n        set: function (value) {\r\n            this.values[0] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"g\", {\r\n        get: function () {\r\n            return this.values[1];\r\n        },\r\n        set: function (value) {\r\n            this.values[1] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"b\", {\r\n        get: function () {\r\n            return this.values[2];\r\n        },\r\n        set: function (value) {\r\n            this.values[2] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"a\", {\r\n        get: function () {\r\n            return this.values[3];\r\n        },\r\n        set: function (value) {\r\n            this.values[3] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"rg\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"rgb\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(V4.prototype, \"rgba\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n                this.values[3],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n            this.values[3] = values[3];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    V4.mix = function (vector, vector2, time, dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        dest.x = vector.x + time * (vector2.x - vector.x);\r\n        dest.y = vector.y + time * (vector2.y - vector.y);\r\n        dest.z = vector.z + time * (vector2.z - vector.z);\r\n        dest.w = vector.w + time * (vector2.w - vector.w);\r\n        return dest;\r\n    };\r\n    V4.sum = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        dest.x = vector.x + vector2.x;\r\n        dest.y = vector.y + vector2.y;\r\n        dest.z = vector.z + vector2.z;\r\n        dest.w = vector.w + vector2.w;\r\n        return dest;\r\n    };\r\n    V4.difference = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        dest.x = vector.x - vector2.x;\r\n        dest.y = vector.y - vector2.y;\r\n        dest.z = vector.z - vector2.z;\r\n        dest.w = vector.w - vector2.w;\r\n        return dest;\r\n    };\r\n    V4.product = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        dest.x = vector.x * vector2.x;\r\n        dest.y = vector.y * vector2.y;\r\n        dest.z = vector.z * vector2.z;\r\n        dest.w = vector.w * vector2.w;\r\n        return dest;\r\n    };\r\n    V4.quotient = function (vector, vector2, dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        dest.x = vector.x / vector2.x;\r\n        dest.y = vector.y / vector2.y;\r\n        dest.z = vector.z / vector2.z;\r\n        dest.w = vector.w / vector2.w;\r\n        return dest;\r\n    };\r\n    V4.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    V4.prototype.reset = function () {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 0;\r\n    };\r\n    V4.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        dest.x = this.x;\r\n        dest.y = this.y;\r\n        dest.z = this.z;\r\n        dest.w = this.w;\r\n        return dest;\r\n    };\r\n    V4.prototype.negate = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        dest.x = -this.x;\r\n        dest.y = -this.y;\r\n        dest.z = -this.z;\r\n        dest.w = -this.w;\r\n        return dest;\r\n    };\r\n    V4.prototype.equals = function (vector, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        if (Math.abs(this.x - vector.x) > threshold) {\r\n            return false;\r\n        }\r\n        if (Math.abs(this.y - vector.y) > threshold) {\r\n            return false;\r\n        }\r\n        if (Math.abs(this.z - vector.z) > threshold) {\r\n            return false;\r\n        }\r\n        if (Math.abs(this.w - vector.w) > threshold) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    V4.prototype.length = function () {\r\n        return Math.sqrt(this.squaredLength());\r\n    };\r\n    V4.prototype.squaredLength = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        return (x * x + y * y + z * z + w * w);\r\n    };\r\n    V4.prototype.add = function (vector) {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n        this.z += vector.z;\r\n        this.w += vector.w;\r\n        return this;\r\n    };\r\n    V4.prototype.subtract = function (vector) {\r\n        this.x -= vector.x;\r\n        this.y -= vector.y;\r\n        this.z -= vector.z;\r\n        this.w -= vector.w;\r\n        return this;\r\n    };\r\n    V4.prototype.multiply = function (vector) {\r\n        this.x *= vector.x;\r\n        this.y *= vector.y;\r\n        this.z *= vector.z;\r\n        this.w *= vector.w;\r\n        return this;\r\n    };\r\n    V4.prototype.divide = function (vector) {\r\n        this.x /= vector.x;\r\n        this.y /= vector.y;\r\n        this.z /= vector.z;\r\n        this.w /= vector.w;\r\n        return this;\r\n    };\r\n    V4.prototype.scale = function (value, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        dest.x *= value;\r\n        dest.y *= value;\r\n        dest.z *= value;\r\n        dest.w *= value;\r\n        return dest;\r\n    };\r\n    V4.prototype.normalize = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        var length = this.length();\r\n        if (length === 1) {\r\n            return this;\r\n        }\r\n        if (length === 0) {\r\n            dest.x *= 0;\r\n            dest.y *= 0;\r\n            dest.z *= 0;\r\n            dest.w *= 0;\r\n            return dest;\r\n        }\r\n        length = 1.0 / length;\r\n        dest.x *= length;\r\n        dest.y *= length;\r\n        dest.z *= length;\r\n        dest.w *= length;\r\n        return dest;\r\n    };\r\n    V4.prototype.multiplyMat4 = function (matrix, dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        return matrix.multiplyVec4(this, dest);\r\n    };\r\n    V4.prototype.dot = function (dest) {\r\n        return (this.x * dest.x + this.y * dest.y + this.z * dest.z); // ignore w\r\n    };\r\n    V4.zero = new V4([0, 0, 0, 1]);\r\n    V4.one = new V4([1, 1, 1, 1]);\r\n    return V4;\r\n}());\r\nexport { V4 };\r\nvar M2 = /** @class */ (function () {\r\n    function M2(values) {\r\n        this.values = new Float32Array(4);\r\n        if (values !== undefined) {\r\n            this.init(values);\r\n        }\r\n    }\r\n    M2.product = function (m1, m2, result) {\r\n        var a11 = m1.at(0);\r\n        var a12 = m1.at(1);\r\n        var a21 = m1.at(2);\r\n        var a22 = m1.at(3);\r\n        if (result) {\r\n            result.init([\r\n                a11 * m2.at(0) + a12 * m2.at(2),\r\n                a11 * m2.at(1) + a12 * m2.at(3),\r\n                a21 * m2.at(0) + a22 * m2.at(2),\r\n                a21 * m2.at(1) + a22 * m2.at(3),\r\n            ]);\r\n            return result;\r\n        }\r\n        else {\r\n            return new M2([\r\n                a11 * m2.at(0) + a12 * m2.at(2),\r\n                a11 * m2.at(1) + a12 * m2.at(3),\r\n                a21 * m2.at(0) + a22 * m2.at(2),\r\n                a21 * m2.at(1) + a22 * m2.at(3),\r\n            ]);\r\n        }\r\n    };\r\n    M2.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    M2.prototype.init = function (values) {\r\n        for (var i = 0; i < 4; i++) {\r\n            this.values[i] = values[i];\r\n        }\r\n        return this;\r\n    };\r\n    M2.prototype.reset = function () {\r\n        for (var i = 0; i < 4; i++) {\r\n            this.values[i] = 0;\r\n        }\r\n    };\r\n    M2.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new M2();\r\n        }\r\n        for (var i = 0; i < 4; i++) {\r\n            dest.values[i] = this.values[i];\r\n        }\r\n        return dest;\r\n    };\r\n    M2.prototype.all = function () {\r\n        var data = [];\r\n        for (var i = 0; i < 4; i++) {\r\n            data[i] = this.values[i];\r\n        }\r\n        return data;\r\n    };\r\n    M2.prototype.row = function (index) {\r\n        return [\r\n            this.values[index * 2 + 0],\r\n            this.values[index * 2 + 1],\r\n        ];\r\n    };\r\n    M2.prototype.col = function (index) {\r\n        return [\r\n            this.values[index],\r\n            this.values[index + 2],\r\n        ];\r\n    };\r\n    M2.prototype.equals = function (matrix, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        for (var i = 0; i < 4; i++) {\r\n            if (Math.abs(this.values[i] - matrix.at(i)) > threshold) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    M2.prototype.determinant = function () {\r\n        return this.values[0] * this.values[3] - this.values[2] * this.values[1];\r\n    };\r\n    M2.prototype.setIdentity = function () {\r\n        this.values[0] = 1;\r\n        this.values[1] = 0;\r\n        this.values[2] = 0;\r\n        this.values[3] = 1;\r\n        return this;\r\n    };\r\n    M2.prototype.transpose = function () {\r\n        var temp = this.values[1];\r\n        this.values[1] = this.values[2];\r\n        this.values[2] = temp;\r\n        return this;\r\n    };\r\n    M2.prototype.inverse = function () {\r\n        var det = this.determinant();\r\n        if (!det) {\r\n            return null;\r\n        }\r\n        det = 1.0 / det;\r\n        var a11 = this.values[0];\r\n        this.values[0] = det * (this.values[3]);\r\n        this.values[1] = det * (-this.values[1]);\r\n        this.values[2] = det * (-this.values[2]);\r\n        this.values[3] = det * a11;\r\n        return this;\r\n    };\r\n    M2.prototype.multiply = function (matrix) {\r\n        var a11 = this.values[0];\r\n        var a12 = this.values[1];\r\n        var a21 = this.values[2];\r\n        var a22 = this.values[3];\r\n        this.values[0] = a11 * matrix.at(0) + a12 * matrix.at(2);\r\n        this.values[1] = a11 * matrix.at(1) + a12 * matrix.at(3);\r\n        this.values[2] = a21 * matrix.at(0) + a22 * matrix.at(2);\r\n        this.values[3] = a21 * matrix.at(1) + a22 * matrix.at(3);\r\n        return this;\r\n    };\r\n    M2.prototype.rotate = function (angle) {\r\n        var a11 = this.values[0];\r\n        var a12 = this.values[1];\r\n        var a21 = this.values[2];\r\n        var a22 = this.values[3];\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n        this.values[0] = a11 * cos + a12 * sin;\r\n        this.values[1] = a11 * -sin + a12 * cos;\r\n        this.values[2] = a21 * cos + a22 * sin;\r\n        this.values[3] = a21 * -sin + a22 * cos;\r\n        return this;\r\n    };\r\n    M2.prototype.multiplyVec2 = function (vector, result) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        if (result) {\r\n            result.xy = [\r\n                x * this.values[0] + y * this.values[1],\r\n                x * this.values[2] + y * this.values[3],\r\n            ];\r\n            return result;\r\n        }\r\n        else {\r\n            return new V2([\r\n                x * this.values[0] + y * this.values[1],\r\n                x * this.values[2] + y * this.values[3],\r\n            ]);\r\n        }\r\n    };\r\n    M2.prototype.scale = function (vector) {\r\n        var a11 = this.values[0];\r\n        var a12 = this.values[1];\r\n        var a21 = this.values[2];\r\n        var a22 = this.values[3];\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        this.values[0] = a11 * x;\r\n        this.values[1] = a12 * y;\r\n        this.values[2] = a21 * x;\r\n        this.values[3] = a22 * y;\r\n        return this;\r\n    };\r\n    M2.identity = new M2().setIdentity();\r\n    return M2;\r\n}());\r\nexport { M2 };\r\nvar M3 = /** @class */ (function () {\r\n    function M3(values) {\r\n        this.values = new Float32Array(9);\r\n        if (values !== undefined) {\r\n            this.init(values);\r\n        }\r\n    }\r\n    M3.product = function (m1, m2, result) {\r\n        var a00 = m1.at(0);\r\n        var a01 = m1.at(1);\r\n        var a02 = m1.at(2);\r\n        var a10 = m1.at(3);\r\n        var a11 = m1.at(4);\r\n        var a12 = m1.at(5);\r\n        var a20 = m1.at(6);\r\n        var a21 = m1.at(7);\r\n        var a22 = m1.at(8);\r\n        var b00 = m2.at(0);\r\n        var b01 = m2.at(1);\r\n        var b02 = m2.at(2);\r\n        var b10 = m2.at(3);\r\n        var b11 = m2.at(4);\r\n        var b12 = m2.at(5);\r\n        var b20 = m2.at(6);\r\n        var b21 = m2.at(7);\r\n        var b22 = m2.at(8);\r\n        if (result) {\r\n            result.init([\r\n                b00 * a00 + b01 * a10 + b02 * a20,\r\n                b00 * a01 + b01 * a11 + b02 * a21,\r\n                b00 * a02 + b01 * a12 + b02 * a22,\r\n                b10 * a00 + b11 * a10 + b12 * a20,\r\n                b10 * a01 + b11 * a11 + b12 * a21,\r\n                b10 * a02 + b11 * a12 + b12 * a22,\r\n                b20 * a00 + b21 * a10 + b22 * a20,\r\n                b20 * a01 + b21 * a11 + b22 * a21,\r\n                b20 * a02 + b21 * a12 + b22 * a22,\r\n            ]);\r\n            return result;\r\n        }\r\n        else {\r\n            return new M3([\r\n                b00 * a00 + b01 * a10 + b02 * a20,\r\n                b00 * a01 + b01 * a11 + b02 * a21,\r\n                b00 * a02 + b01 * a12 + b02 * a22,\r\n                b10 * a00 + b11 * a10 + b12 * a20,\r\n                b10 * a01 + b11 * a11 + b12 * a21,\r\n                b10 * a02 + b11 * a12 + b12 * a22,\r\n                b20 * a00 + b21 * a10 + b22 * a20,\r\n                b20 * a01 + b21 * a11 + b22 * a21,\r\n                b20 * a02 + b21 * a12 + b22 * a22,\r\n            ]);\r\n        }\r\n    };\r\n    M3.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    M3.prototype.init = function (values) {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.values[i] = values[i];\r\n        }\r\n        return this;\r\n    };\r\n    M3.prototype.reset = function () {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.values[i] = 0;\r\n        }\r\n    };\r\n    M3.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new M3();\r\n        }\r\n        for (var i = 0; i < 9; i++) {\r\n            dest.values[i] = this.values[i];\r\n        }\r\n        return dest;\r\n    };\r\n    M3.prototype.all = function () {\r\n        var data = [];\r\n        for (var i = 0; i < 9; i++) {\r\n            data[i] = this.values[i];\r\n        }\r\n        return data;\r\n    };\r\n    M3.prototype.row = function (index) {\r\n        return [\r\n            this.values[index * 3 + 0],\r\n            this.values[index * 3 + 1],\r\n            this.values[index * 3 + 2],\r\n        ];\r\n    };\r\n    M3.prototype.col = function (index) {\r\n        return [\r\n            this.values[index],\r\n            this.values[index + 3],\r\n            this.values[index + 6],\r\n        ];\r\n    };\r\n    M3.prototype.equals = function (matrix, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        for (var i = 0; i < 9; i++) {\r\n            if (Math.abs(this.values[i] - matrix.at(i)) > threshold) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    M3.prototype.determinant = function () {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a10 = this.values[3];\r\n        var a11 = this.values[4];\r\n        var a12 = this.values[5];\r\n        var a20 = this.values[6];\r\n        var a21 = this.values[7];\r\n        var a22 = this.values[8];\r\n        var det01 = a22 * a11 - a12 * a21;\r\n        var det11 = -a22 * a10 + a12 * a20;\r\n        var det21 = a21 * a10 - a11 * a20;\r\n        return a00 * det01 + a01 * det11 + a02 * det21;\r\n    };\r\n    M3.prototype.setIdentity = function () {\r\n        this.values[0] = 1;\r\n        this.values[1] = 0;\r\n        this.values[2] = 0;\r\n        this.values[3] = 0;\r\n        this.values[4] = 1;\r\n        this.values[5] = 0;\r\n        this.values[6] = 0;\r\n        this.values[7] = 0;\r\n        this.values[8] = 1;\r\n        return this;\r\n    };\r\n    M3.prototype.transpose = function () {\r\n        var temp01 = this.values[1];\r\n        var temp02 = this.values[2];\r\n        var temp12 = this.values[5];\r\n        this.values[1] = this.values[3];\r\n        this.values[2] = this.values[6];\r\n        this.values[3] = temp01;\r\n        this.values[5] = this.values[7];\r\n        this.values[6] = temp02;\r\n        this.values[7] = temp12;\r\n        return this;\r\n    };\r\n    M3.prototype.inverse = function () {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a10 = this.values[3];\r\n        var a11 = this.values[4];\r\n        var a12 = this.values[5];\r\n        var a20 = this.values[6];\r\n        var a21 = this.values[7];\r\n        var a22 = this.values[8];\r\n        var det01 = a22 * a11 - a12 * a21;\r\n        var det11 = -a22 * a10 + a12 * a20;\r\n        var det21 = a21 * a10 - a11 * a20;\r\n        var det = a00 * det01 + a01 * det11 + a02 * det21;\r\n        if (!det) {\r\n            return null;\r\n        }\r\n        det = 1.0 / det;\r\n        this.values[0] = det01 * det;\r\n        this.values[1] = (-a22 * a01 + a02 * a21) * det;\r\n        this.values[2] = (a12 * a01 - a02 * a11) * det;\r\n        this.values[3] = det11 * det;\r\n        this.values[4] = (a22 * a00 - a02 * a20) * det;\r\n        this.values[5] = (-a12 * a00 + a02 * a10) * det;\r\n        this.values[6] = det21 * det;\r\n        this.values[7] = (-a21 * a00 + a01 * a20) * det;\r\n        this.values[8] = (a11 * a00 - a01 * a10) * det;\r\n        return this;\r\n    };\r\n    M3.prototype.multiply = function (matrix) {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a10 = this.values[3];\r\n        var a11 = this.values[4];\r\n        var a12 = this.values[5];\r\n        var a20 = this.values[6];\r\n        var a21 = this.values[7];\r\n        var a22 = this.values[8];\r\n        var b00 = matrix.at(0);\r\n        var b01 = matrix.at(1);\r\n        var b02 = matrix.at(2);\r\n        var b10 = matrix.at(3);\r\n        var b11 = matrix.at(4);\r\n        var b12 = matrix.at(5);\r\n        var b20 = matrix.at(6);\r\n        var b21 = matrix.at(7);\r\n        var b22 = matrix.at(8);\r\n        this.values[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n        this.values[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n        this.values[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n        this.values[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n        this.values[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n        this.values[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n        this.values[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n        this.values[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n        this.values[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n        return this;\r\n    };\r\n    M3.prototype.multiplyVec2 = function (vector, result) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        if (result) {\r\n            result.xy = [\r\n                x * this.values[0] + y * this.values[3] + this.values[6],\r\n                x * this.values[1] + y * this.values[4] + this.values[7],\r\n            ];\r\n            return result;\r\n        }\r\n        else {\r\n            return new V2([\r\n                x * this.values[0] + y * this.values[3] + this.values[6],\r\n                x * this.values[1] + y * this.values[4] + this.values[7],\r\n            ]);\r\n        }\r\n    };\r\n    M3.prototype.multiplyVec3 = function (vector, result) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        if (result) {\r\n            result.xyz = [\r\n                x * this.values[0] + y * this.values[3] + z * this.values[6],\r\n                x * this.values[1] + y * this.values[4] + z * this.values[7],\r\n                x * this.values[2] + y * this.values[5] + z * this.values[8],\r\n            ];\r\n            return result;\r\n        }\r\n        else {\r\n            return new V3([\r\n                x * this.values[0] + y * this.values[3] + z * this.values[6],\r\n                x * this.values[1] + y * this.values[4] + z * this.values[7],\r\n                x * this.values[2] + y * this.values[5] + z * this.values[8],\r\n            ]);\r\n        }\r\n    };\r\n    M3.prototype.toMat4 = function (result) {\r\n        if (result) {\r\n            result.init([\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n                0,\r\n                this.values[3],\r\n                this.values[4],\r\n                this.values[5],\r\n                0,\r\n                this.values[6],\r\n                this.values[7],\r\n                this.values[8],\r\n                0,\r\n                0,\r\n                0,\r\n                0,\r\n                1,\r\n            ]);\r\n            return result;\r\n        }\r\n        else {\r\n            return new M4([\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n                0,\r\n                this.values[3],\r\n                this.values[4],\r\n                this.values[5],\r\n                0,\r\n                this.values[6],\r\n                this.values[7],\r\n                this.values[8],\r\n                0,\r\n                0,\r\n                0,\r\n                0,\r\n                1,\r\n            ]);\r\n        }\r\n    };\r\n    M3.prototype.toQuat = function () {\r\n        var m00 = this.values[0];\r\n        var m01 = this.values[1];\r\n        var m02 = this.values[2];\r\n        var m10 = this.values[3];\r\n        var m11 = this.values[4];\r\n        var m12 = this.values[5];\r\n        var m20 = this.values[6];\r\n        var m21 = this.values[7];\r\n        var m22 = this.values[8];\r\n        var fourXSquaredMinus1 = m00 - m11 - m22;\r\n        var fourYSquaredMinus1 = m11 - m00 - m22;\r\n        var fourZSquaredMinus1 = m22 - m00 - m11;\r\n        var fourWSquaredMinus1 = m00 + m11 + m22;\r\n        var biggestIndex = 0;\r\n        var fourBiggestSquaredMinus1 = fourWSquaredMinus1;\r\n        if (fourXSquaredMinus1 > fourBiggestSquaredMinus1) {\r\n            fourBiggestSquaredMinus1 = fourXSquaredMinus1;\r\n            biggestIndex = 1;\r\n        }\r\n        if (fourYSquaredMinus1 > fourBiggestSquaredMinus1) {\r\n            fourBiggestSquaredMinus1 = fourYSquaredMinus1;\r\n            biggestIndex = 2;\r\n        }\r\n        if (fourZSquaredMinus1 > fourBiggestSquaredMinus1) {\r\n            fourBiggestSquaredMinus1 = fourZSquaredMinus1;\r\n            biggestIndex = 3;\r\n        }\r\n        var biggestVal = Math.sqrt(fourBiggestSquaredMinus1 + 1) * 0.5;\r\n        var mult = 0.25 / biggestVal;\r\n        var result = new Quat();\r\n        switch (biggestIndex) {\r\n            case 0:\r\n                result.w = biggestVal;\r\n                result.x = (m12 - m21) * mult;\r\n                result.y = (m20 - m02) * mult;\r\n                result.z = (m01 - m10) * mult;\r\n                break;\r\n            case 1:\r\n                result.w = (m12 - m21) * mult;\r\n                result.x = biggestVal;\r\n                result.y = (m01 + m10) * mult;\r\n                result.z = (m20 + m02) * mult;\r\n                break;\r\n            case 2:\r\n                result.w = (m20 - m02) * mult;\r\n                result.x = (m01 + m10) * mult;\r\n                result.y = biggestVal;\r\n                result.z = (m12 + m21) * mult;\r\n                break;\r\n            case 3:\r\n                result.w = (m01 - m10) * mult;\r\n                result.x = (m20 + m02) * mult;\r\n                result.y = (m12 + m21) * mult;\r\n                result.z = biggestVal;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n    M3.prototype.rotate = function (angle, axis) {\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var length = Math.sqrt(x * x + y * y + z * z);\r\n        if (!length) {\r\n            return null;\r\n        }\r\n        if (length !== 1) {\r\n            length = 1 / length;\r\n            x *= length;\r\n            y *= length;\r\n            z *= length;\r\n        }\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        var t = 1.0 - c;\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a10 = this.values[4];\r\n        var a11 = this.values[5];\r\n        var a12 = this.values[6];\r\n        var a20 = this.values[8];\r\n        var a21 = this.values[9];\r\n        var a22 = this.values[10];\r\n        var b00 = x * x * t + c;\r\n        var b01 = y * x * t + z * s;\r\n        var b02 = z * x * t - y * s;\r\n        var b10 = x * y * t - z * s;\r\n        var b11 = y * y * t + c;\r\n        var b12 = z * y * t + x * s;\r\n        var b20 = x * z * t + y * s;\r\n        var b21 = y * z * t - x * s;\r\n        var b22 = z * z * t + c;\r\n        this.values[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n        this.values[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n        this.values[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n        this.values[3] = a00 * b10 + a10 * b11 + a20 * b12;\r\n        this.values[4] = a01 * b10 + a11 * b11 + a21 * b12;\r\n        this.values[5] = a02 * b10 + a12 * b11 + a22 * b12;\r\n        this.values[6] = a00 * b20 + a10 * b21 + a20 * b22;\r\n        this.values[7] = a01 * b20 + a11 * b21 + a21 * b22;\r\n        this.values[8] = a02 * b20 + a12 * b21 + a22 * b22;\r\n        return this;\r\n    };\r\n    M3.identity = new M3().setIdentity();\r\n    return M3;\r\n}());\r\nexport { M3 };\r\nvar M4 = /** @class */ (function () {\r\n    function M4(values) {\r\n        this.values = new Float32Array(16);\r\n        if (values !== undefined) {\r\n            this.init(values);\r\n        }\r\n        else {\r\n            this.setIdentity();\r\n        }\r\n    }\r\n    M4.frustum = function (left, right, bottom, top, near, far) {\r\n        var rl = (right - left);\r\n        var tb = (top - bottom);\r\n        var fn = (far - near);\r\n        return new M4([\r\n            (near * 2) / rl,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            (near * 2) / tb,\r\n            0,\r\n            0,\r\n            (right + left) / rl,\r\n            (top + bottom) / tb,\r\n            -(far + near) / fn,\r\n            -1,\r\n            0,\r\n            0,\r\n            -(far * near * 2) / fn,\r\n            0,\r\n        ]);\r\n    };\r\n    M4.perspective = function (fov, aspect, near, far) {\r\n        var top = near * Math.tan(fov * Math.PI / 360.0);\r\n        var right = top * aspect;\r\n        return M4.frustum(-right, right, -top, top, near, far);\r\n    };\r\n    M4.orthographic = function (left, right, bottom, top, near, far) {\r\n        var rl = (right - left);\r\n        var tb = (top - bottom);\r\n        var fn = (far - near);\r\n        return new M4([\r\n            2 / rl,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            2 / tb,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            -2 / fn,\r\n            0,\r\n            -(left + right) / rl,\r\n            -(top + bottom) / tb,\r\n            -(far + near) / fn,\r\n            1,\r\n        ]);\r\n    };\r\n    M4.lookAt = function (position, target, up) {\r\n        if (up === void 0) { up = V3.up; }\r\n        if (position.equals(target)) {\r\n            return this.identity;\r\n        }\r\n        var z = V3.difference(position, target).normalize();\r\n        var x = V3.cross(up, z).normalize();\r\n        var y = V3.cross(z, x).normalize();\r\n        return new M4([\r\n            x.x,\r\n            y.x,\r\n            z.x,\r\n            0,\r\n            x.y,\r\n            y.y,\r\n            z.y,\r\n            0,\r\n            x.z,\r\n            y.z,\r\n            z.z,\r\n            0,\r\n            -V3.dot(x, position),\r\n            -V3.dot(y, position),\r\n            -V3.dot(z, position),\r\n            1,\r\n        ]);\r\n    };\r\n    M4.product = function (m1, m2, result) {\r\n        var a00 = m1.at(0);\r\n        var a01 = m1.at(1);\r\n        var a02 = m1.at(2);\r\n        var a03 = m1.at(3);\r\n        var a10 = m1.at(4);\r\n        var a11 = m1.at(5);\r\n        var a12 = m1.at(6);\r\n        var a13 = m1.at(7);\r\n        var a20 = m1.at(8);\r\n        var a21 = m1.at(9);\r\n        var a22 = m1.at(10);\r\n        var a23 = m1.at(11);\r\n        var a30 = m1.at(12);\r\n        var a31 = m1.at(13);\r\n        var a32 = m1.at(14);\r\n        var a33 = m1.at(15);\r\n        var b00 = m2.at(0);\r\n        var b01 = m2.at(1);\r\n        var b02 = m2.at(2);\r\n        var b03 = m2.at(3);\r\n        var b10 = m2.at(4);\r\n        var b11 = m2.at(5);\r\n        var b12 = m2.at(6);\r\n        var b13 = m2.at(7);\r\n        var b20 = m2.at(8);\r\n        var b21 = m2.at(9);\r\n        var b22 = m2.at(10);\r\n        var b23 = m2.at(11);\r\n        var b30 = m2.at(12);\r\n        var b31 = m2.at(13);\r\n        var b32 = m2.at(14);\r\n        var b33 = m2.at(15);\r\n        if (result) {\r\n            result.init([\r\n                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\r\n                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\r\n                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\r\n                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\r\n                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\r\n                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\r\n                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\r\n                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\r\n                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\r\n                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\r\n                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\r\n                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\r\n                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\r\n                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\r\n                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\r\n                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\r\n            ]);\r\n            return result;\r\n        }\r\n        else {\r\n            return new M4([\r\n                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\r\n                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\r\n                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\r\n                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\r\n                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\r\n                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\r\n                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\r\n                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\r\n                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\r\n                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\r\n                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\r\n                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\r\n                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\r\n                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\r\n                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\r\n                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\r\n            ]);\r\n        }\r\n    };\r\n    M4.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    M4.prototype.init = function (values) {\r\n        for (var i = 0; i < 16; i++) {\r\n            this.values[i] = values[i];\r\n        }\r\n        return this;\r\n    };\r\n    M4.prototype.reset = function () {\r\n        for (var i = 0; i < 16; i++) {\r\n            this.values[i] = 0;\r\n        }\r\n    };\r\n    M4.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new M4();\r\n        }\r\n        for (var i = 0; i < 16; i++) {\r\n            dest.values[i] = this.values[i];\r\n        }\r\n        return dest;\r\n    };\r\n    M4.prototype.all = function () {\r\n        var data = [];\r\n        for (var i = 0; i < 16; i++) {\r\n            data[i] = this.values[i];\r\n        }\r\n        return data;\r\n    };\r\n    M4.prototype.row = function (index) {\r\n        return [\r\n            this.values[index * 4 + 0],\r\n            this.values[index * 4 + 1],\r\n            this.values[index * 4 + 2],\r\n            this.values[index * 4 + 3],\r\n        ];\r\n    };\r\n    M4.prototype.col = function (index) {\r\n        return [\r\n            this.values[index],\r\n            this.values[index + 4],\r\n            this.values[index + 8],\r\n            this.values[index + 12],\r\n        ];\r\n    };\r\n    M4.prototype.equals = function (matrix, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        for (var i = 0; i < 16; i++) {\r\n            if (Math.abs(this.values[i] - matrix.at(i)) > threshold) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    M4.prototype.determinant = function () {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a03 = this.values[3];\r\n        var a10 = this.values[4];\r\n        var a11 = this.values[5];\r\n        var a12 = this.values[6];\r\n        var a13 = this.values[7];\r\n        var a20 = this.values[8];\r\n        var a21 = this.values[9];\r\n        var a22 = this.values[10];\r\n        var a23 = this.values[11];\r\n        var a30 = this.values[12];\r\n        var a31 = this.values[13];\r\n        var a32 = this.values[14];\r\n        var a33 = this.values[15];\r\n        var det00 = a00 * a11 - a01 * a10;\r\n        var det01 = a00 * a12 - a02 * a10;\r\n        var det02 = a00 * a13 - a03 * a10;\r\n        var det03 = a01 * a12 - a02 * a11;\r\n        var det04 = a01 * a13 - a03 * a11;\r\n        var det05 = a02 * a13 - a03 * a12;\r\n        var det06 = a20 * a31 - a21 * a30;\r\n        var det07 = a20 * a32 - a22 * a30;\r\n        var det08 = a20 * a33 - a23 * a30;\r\n        var det09 = a21 * a32 - a22 * a31;\r\n        var det10 = a21 * a33 - a23 * a31;\r\n        var det11 = a22 * a33 - a23 * a32;\r\n        return (det00 * det11 - det01 * det10 + det02 * det09 + det03 * det08 - det04 * det07 + det05 * det06);\r\n    };\r\n    M4.prototype.setIdentity = function () {\r\n        this.values[0] = 1;\r\n        this.values[1] = 0;\r\n        this.values[2] = 0;\r\n        this.values[3] = 0;\r\n        this.values[4] = 0;\r\n        this.values[5] = 1;\r\n        this.values[6] = 0;\r\n        this.values[7] = 0;\r\n        this.values[8] = 0;\r\n        this.values[9] = 0;\r\n        this.values[10] = 1;\r\n        this.values[11] = 0;\r\n        this.values[12] = 0;\r\n        this.values[13] = 0;\r\n        this.values[14] = 0;\r\n        this.values[15] = 1;\r\n        return this;\r\n    };\r\n    M4.prototype.transpose = function () {\r\n        var temp01 = this.values[1];\r\n        var temp02 = this.values[2];\r\n        var temp03 = this.values[3];\r\n        var temp12 = this.values[6];\r\n        var temp13 = this.values[7];\r\n        var temp23 = this.values[11];\r\n        this.values[1] = this.values[4];\r\n        this.values[2] = this.values[8];\r\n        this.values[3] = this.values[12];\r\n        this.values[4] = temp01;\r\n        this.values[6] = this.values[9];\r\n        this.values[7] = this.values[13];\r\n        this.values[8] = temp02;\r\n        this.values[9] = temp12;\r\n        this.values[11] = this.values[14];\r\n        this.values[12] = temp03;\r\n        this.values[13] = temp13;\r\n        this.values[14] = temp23;\r\n        return this;\r\n    };\r\n    M4.prototype.inverse = function () {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a03 = this.values[3];\r\n        var a10 = this.values[4];\r\n        var a11 = this.values[5];\r\n        var a12 = this.values[6];\r\n        var a13 = this.values[7];\r\n        var a20 = this.values[8];\r\n        var a21 = this.values[9];\r\n        var a22 = this.values[10];\r\n        var a23 = this.values[11];\r\n        var a30 = this.values[12];\r\n        var a31 = this.values[13];\r\n        var a32 = this.values[14];\r\n        var a33 = this.values[15];\r\n        var det00 = a00 * a11 - a01 * a10;\r\n        var det01 = a00 * a12 - a02 * a10;\r\n        var det02 = a00 * a13 - a03 * a10;\r\n        var det03 = a01 * a12 - a02 * a11;\r\n        var det04 = a01 * a13 - a03 * a11;\r\n        var det05 = a02 * a13 - a03 * a12;\r\n        var det06 = a20 * a31 - a21 * a30;\r\n        var det07 = a20 * a32 - a22 * a30;\r\n        var det08 = a20 * a33 - a23 * a30;\r\n        var det09 = a21 * a32 - a22 * a31;\r\n        var det10 = a21 * a33 - a23 * a31;\r\n        var det11 = a22 * a33 - a23 * a32;\r\n        var det = (det00 * det11 - det01 * det10 + det02 * det09 + det03 * det08 - det04 * det07 + det05 * det06);\r\n        if (!det) {\r\n            return null;\r\n        }\r\n        det = 1.0 / det;\r\n        this.values[0] = (a11 * det11 - a12 * det10 + a13 * det09) * det;\r\n        this.values[1] = (-a01 * det11 + a02 * det10 - a03 * det09) * det;\r\n        this.values[2] = (a31 * det05 - a32 * det04 + a33 * det03) * det;\r\n        this.values[3] = (-a21 * det05 + a22 * det04 - a23 * det03) * det;\r\n        this.values[4] = (-a10 * det11 + a12 * det08 - a13 * det07) * det;\r\n        this.values[5] = (a00 * det11 - a02 * det08 + a03 * det07) * det;\r\n        this.values[6] = (-a30 * det05 + a32 * det02 - a33 * det01) * det;\r\n        this.values[7] = (a20 * det05 - a22 * det02 + a23 * det01) * det;\r\n        this.values[8] = (a10 * det10 - a11 * det08 + a13 * det06) * det;\r\n        this.values[9] = (-a00 * det10 + a01 * det08 - a03 * det06) * det;\r\n        this.values[10] = (a30 * det04 - a31 * det02 + a33 * det00) * det;\r\n        this.values[11] = (-a20 * det04 + a21 * det02 - a23 * det00) * det;\r\n        this.values[12] = (-a10 * det09 + a11 * det07 - a12 * det06) * det;\r\n        this.values[13] = (a00 * det09 - a01 * det07 + a02 * det06) * det;\r\n        this.values[14] = (-a30 * det03 + a31 * det01 - a32 * det00) * det;\r\n        this.values[15] = (a20 * det03 - a21 * det01 + a22 * det00) * det;\r\n        return this;\r\n    };\r\n    M4.prototype.multiply = function (matrix) {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a03 = this.values[3];\r\n        var a10 = this.values[4];\r\n        var a11 = this.values[5];\r\n        var a12 = this.values[6];\r\n        var a13 = this.values[7];\r\n        var a20 = this.values[8];\r\n        var a21 = this.values[9];\r\n        var a22 = this.values[10];\r\n        var a23 = this.values[11];\r\n        var a30 = this.values[12];\r\n        var a31 = this.values[13];\r\n        var a32 = this.values[14];\r\n        var a33 = this.values[15];\r\n        var b0 = matrix.at(0);\r\n        var b1 = matrix.at(1);\r\n        var b2 = matrix.at(2);\r\n        var b3 = matrix.at(3);\r\n        this.values[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        this.values[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        this.values[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        this.values[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n        b0 = matrix.at(4);\r\n        b1 = matrix.at(5);\r\n        b2 = matrix.at(6);\r\n        b3 = matrix.at(7);\r\n        this.values[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        this.values[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        this.values[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        this.values[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n        b0 = matrix.at(8);\r\n        b1 = matrix.at(9);\r\n        b2 = matrix.at(10);\r\n        b3 = matrix.at(11);\r\n        this.values[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        this.values[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        this.values[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        this.values[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n        b0 = matrix.at(12);\r\n        b1 = matrix.at(13);\r\n        b2 = matrix.at(14);\r\n        b3 = matrix.at(15);\r\n        this.values[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        this.values[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        this.values[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        this.values[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n        return this;\r\n    };\r\n    M4.prototype.multiplyVec3 = function (vector) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        return new V3([\r\n            this.values[0] * x + this.values[4] * y + this.values[8] * z + this.values[12],\r\n            this.values[1] * x + this.values[5] * y + this.values[9] * z + this.values[13],\r\n            this.values[2] * x + this.values[6] * y + this.values[10] * z + this.values[14],\r\n        ]);\r\n    };\r\n    M4.prototype.multiplyVec4 = function (vector, dest) {\r\n        if (!dest) {\r\n            dest = new V4();\r\n        }\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        var w = vector.w;\r\n        dest.x = this.values[0] * x + this.values[4] * y + this.values[8] * z + this.values[12] * w;\r\n        dest.y = this.values[1] * x + this.values[5] * y + this.values[9] * z + this.values[13] * w;\r\n        dest.z = this.values[2] * x + this.values[6] * y + this.values[10] * z + this.values[14] * w;\r\n        dest.w = this.values[3] * x + this.values[7] * y + this.values[11] * z + this.values[15] * w;\r\n        return dest;\r\n    };\r\n    M4.prototype.toMat3 = function () {\r\n        return new M3([\r\n            this.values[0],\r\n            this.values[1],\r\n            this.values[2],\r\n            this.values[4],\r\n            this.values[5],\r\n            this.values[6],\r\n            this.values[8],\r\n            this.values[9],\r\n            this.values[10],\r\n        ]);\r\n    };\r\n    M4.prototype.toInverseMat3 = function () {\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a10 = this.values[4];\r\n        var a11 = this.values[5];\r\n        var a12 = this.values[6];\r\n        var a20 = this.values[8];\r\n        var a21 = this.values[9];\r\n        var a22 = this.values[10];\r\n        var det01 = a22 * a11 - a12 * a21;\r\n        var det11 = -a22 * a10 + a12 * a20;\r\n        var det21 = a21 * a10 - a11 * a20;\r\n        var det = a00 * det01 + a01 * det11 + a02 * det21;\r\n        if (!det) {\r\n            return null;\r\n        }\r\n        det = 1.0 / det;\r\n        return new M3([\r\n            det01 * det,\r\n            (-a22 * a01 + a02 * a21) * det,\r\n            (a12 * a01 - a02 * a11) * det,\r\n            det11 * det,\r\n            (a22 * a00 - a02 * a20) * det,\r\n            (-a12 * a00 + a02 * a10) * det,\r\n            det21 * det,\r\n            (-a21 * a00 + a01 * a20) * det,\r\n            (a11 * a00 - a01 * a10) * det,\r\n        ]);\r\n    };\r\n    M4.prototype.translate = function (vector) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        this.values[12] += this.values[0] * x + this.values[4] * y + this.values[8] * z;\r\n        this.values[13] += this.values[1] * x + this.values[5] * y + this.values[9] * z;\r\n        this.values[14] += this.values[2] * x + this.values[6] * y + this.values[10] * z;\r\n        this.values[15] += this.values[3] * x + this.values[7] * y + this.values[11] * z;\r\n        return this;\r\n    };\r\n    M4.prototype.scale = function (vector) {\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        this.values[0] *= x;\r\n        this.values[1] *= x;\r\n        this.values[2] *= x;\r\n        this.values[3] *= x;\r\n        this.values[4] *= y;\r\n        this.values[5] *= y;\r\n        this.values[6] *= y;\r\n        this.values[7] *= y;\r\n        this.values[8] *= z;\r\n        this.values[9] *= z;\r\n        this.values[10] *= z;\r\n        this.values[11] *= z;\r\n        return this;\r\n    };\r\n    M4.prototype.rotate = function (angle, axis) {\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var length = Math.sqrt(x * x + y * y + z * z);\r\n        if (!length) {\r\n            return null;\r\n        }\r\n        if (length !== 1) {\r\n            length = 1 / length;\r\n            x *= length;\r\n            y *= length;\r\n            z *= length;\r\n        }\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        var t = 1.0 - c;\r\n        var a00 = this.values[0];\r\n        var a01 = this.values[1];\r\n        var a02 = this.values[2];\r\n        var a03 = this.values[3];\r\n        var a10 = this.values[4];\r\n        var a11 = this.values[5];\r\n        var a12 = this.values[6];\r\n        var a13 = this.values[7];\r\n        var a20 = this.values[8];\r\n        var a21 = this.values[9];\r\n        var a22 = this.values[10];\r\n        var a23 = this.values[11];\r\n        var b00 = x * x * t + c;\r\n        var b01 = y * x * t + z * s;\r\n        var b02 = z * x * t - y * s;\r\n        var b10 = x * y * t - z * s;\r\n        var b11 = y * y * t + c;\r\n        var b12 = z * y * t + x * s;\r\n        var b20 = x * z * t + y * s;\r\n        var b21 = y * z * t - x * s;\r\n        var b22 = z * z * t + c;\r\n        this.values[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n        this.values[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n        this.values[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n        this.values[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n        this.values[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n        this.values[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n        this.values[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n        this.values[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n        this.values[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n        this.values[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n        this.values[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n        this.values[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n        return this;\r\n    };\r\n    M4.identity = new M4().setIdentity();\r\n    return M4;\r\n}());\r\nexport { M4 };\r\nvar Quat = /** @class */ (function () {\r\n    function Quat(values) {\r\n        this.values = new Float32Array(4);\r\n        if (values !== undefined) {\r\n            this.xyzw = values;\r\n        }\r\n    }\r\n    Object.defineProperty(Quat.prototype, \"x\", {\r\n        get: function () {\r\n            return this.values[0];\r\n        },\r\n        set: function (value) {\r\n            this.values[0] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Quat.prototype, \"y\", {\r\n        get: function () {\r\n            return this.values[1];\r\n        },\r\n        set: function (value) {\r\n            this.values[1] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Quat.prototype, \"z\", {\r\n        get: function () {\r\n            return this.values[2];\r\n        },\r\n        set: function (value) {\r\n            this.values[2] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Quat.prototype, \"w\", {\r\n        get: function () {\r\n            return this.values[3];\r\n        },\r\n        set: function (value) {\r\n            this.values[3] = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Quat.prototype, \"xy\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Quat.prototype, \"xyz\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Quat.prototype, \"xyzw\", {\r\n        get: function () {\r\n            return [\r\n                this.values[0],\r\n                this.values[1],\r\n                this.values[2],\r\n                this.values[3],\r\n            ];\r\n        },\r\n        set: function (values) {\r\n            this.values[0] = values[0];\r\n            this.values[1] = values[1];\r\n            this.values[2] = values[2];\r\n            this.values[3] = values[3];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Quat.dot = function (q1, q2) {\r\n        return q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\r\n    };\r\n    Quat.sum = function (q1, q2, dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        dest.x = q1.x + q2.x;\r\n        dest.y = q1.y + q2.y;\r\n        dest.z = q1.z + q2.z;\r\n        dest.w = q1.w + q2.w;\r\n        return dest;\r\n    };\r\n    Quat.product = function (q1, q2, dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        var q1x = q1.x;\r\n        var q1y = q1.y;\r\n        var q1z = q1.z;\r\n        var q1w = q1.w;\r\n        var q2x = q2.x;\r\n        var q2y = q2.y;\r\n        var q2z = q2.z;\r\n        var q2w = q2.w;\r\n        dest.x = q1x * q2w + q1w * q2x + q1y * q2z - q1z * q2y;\r\n        dest.y = q1y * q2w + q1w * q2y + q1z * q2x - q1x * q2z;\r\n        dest.z = q1z * q2w + q1w * q2z + q1x * q2y - q1y * q2x;\r\n        dest.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\r\n        return dest;\r\n    };\r\n    Quat.cross = function (q1, q2, dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        var q1x = q1.x;\r\n        var q1y = q1.y;\r\n        var q1z = q1.z;\r\n        var q1w = q1.w;\r\n        var q2x = q2.x;\r\n        var q2y = q2.y;\r\n        var q2z = q2.z;\r\n        var q2w = q2.w;\r\n        dest.x = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\r\n        dest.y = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\r\n        dest.z = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\r\n        dest.w = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\r\n        return dest;\r\n    };\r\n    Quat.shortMix = function (q1, q2, time, dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        if (time <= 0.0) {\r\n            dest.xyzw = q1.xyzw;\r\n            return dest;\r\n        }\r\n        else if (time >= 1.0) {\r\n            dest.xyzw = q2.xyzw;\r\n            return dest;\r\n        }\r\n        var cos = Quat.dot(q1, q2);\r\n        var q2a = q2.copy();\r\n        if (cos < 0.0) {\r\n            q2a.inverse();\r\n            cos = -cos;\r\n        }\r\n        var k0;\r\n        var k1;\r\n        if (cos > 0.9999) {\r\n            k0 = 1 - time;\r\n            k1 = 0 + time;\r\n        }\r\n        else {\r\n            var sin = Math.sqrt(1 - cos * cos);\r\n            var angle = Math.atan2(sin, cos);\r\n            var oneOverSin = 1 / sin;\r\n            k0 = Math.sin((1 - time) * angle) * oneOverSin;\r\n            k1 = Math.sin((0 + time) * angle) * oneOverSin;\r\n        }\r\n        dest.x = k0 * q1.x + k1 * q2a.x;\r\n        dest.y = k0 * q1.y + k1 * q2a.y;\r\n        dest.z = k0 * q1.z + k1 * q2a.z;\r\n        dest.w = k0 * q1.w + k1 * q2a.w;\r\n        return dest;\r\n    };\r\n    Quat.mix = function (q1, q2, time, dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        var cosHalfTheta = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\r\n        if (Math.abs(cosHalfTheta) >= 1.0) {\r\n            dest.xyzw = q1.xyzw;\r\n            return dest;\r\n        }\r\n        var halfTheta = Math.acos(cosHalfTheta);\r\n        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\r\n        if (Math.abs(sinHalfTheta) < 0.001) {\r\n            dest.x = q1.x * 0.5 + q2.x * 0.5;\r\n            dest.y = q1.y * 0.5 + q2.y * 0.5;\r\n            dest.z = q1.z * 0.5 + q2.z * 0.5;\r\n            dest.w = q1.w * 0.5 + q2.w * 0.5;\r\n            return dest;\r\n        }\r\n        var ratioA = Math.sin((1 - time) * halfTheta) / sinHalfTheta;\r\n        var ratioB = Math.sin(time * halfTheta) / sinHalfTheta;\r\n        dest.x = q1.x * ratioA + q2.x * ratioB;\r\n        dest.y = q1.y * ratioA + q2.y * ratioB;\r\n        dest.z = q1.z * ratioA + q2.z * ratioB;\r\n        dest.w = q1.w * ratioA + q2.w * ratioB;\r\n        return dest;\r\n    };\r\n    Quat.fromAxisAngle = function (axis, angle, dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        angle *= 0.5;\r\n        var sin = Math.sin(angle);\r\n        dest.x = axis.x * sin;\r\n        dest.y = axis.y * sin;\r\n        dest.z = axis.z * sin;\r\n        dest.w = Math.cos(angle);\r\n        return dest;\r\n    };\r\n    Quat.prototype.at = function (index) {\r\n        return this.values[index];\r\n    };\r\n    Quat.prototype.reset = function () {\r\n        for (var i = 0; i < 4; i++) {\r\n            this.values[i] = 0;\r\n        }\r\n    };\r\n    Quat.prototype.copy = function (dest) {\r\n        if (!dest) {\r\n            dest = new Quat();\r\n        }\r\n        for (var i = 0; i < 4; i++) {\r\n            dest.values[i] = this.values[i];\r\n        }\r\n        return dest;\r\n    };\r\n    Quat.prototype.roll = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        return Math.atan2(2.0 * (x * y + w * z), w * w + x * x - y * y - z * z);\r\n    };\r\n    Quat.prototype.pitch = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        return Math.atan2(2.0 * (y * z + w * x), w * w - x * x - y * y + z * z);\r\n    };\r\n    Quat.prototype.yaw = function () {\r\n        return Math.asin(2.0 * (this.x * this.z - this.w * this.y));\r\n    };\r\n    Quat.prototype.equals = function (vector, threshold) {\r\n        if (threshold === void 0) { threshold = epsilon; }\r\n        for (var i = 0; i < 4; i++) {\r\n            if (Math.abs(this.values[i] - vector.at(i)) > threshold) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Quat.prototype.setIdentity = function () {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 1;\r\n        return this;\r\n    };\r\n    Quat.prototype.calculateW = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        this.w = -(Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z)));\r\n        return this;\r\n    };\r\n    Quat.prototype.inverse = function () {\r\n        var dot = Quat.dot(this, this);\r\n        if (!dot) {\r\n            this.xyzw = [0, 0, 0, 0];\r\n            return this;\r\n        }\r\n        var invDot = dot ? 1.0 / dot : 0;\r\n        this.x *= -invDot;\r\n        this.y *= -invDot;\r\n        this.z *= -invDot;\r\n        this.w *= invDot;\r\n        return this;\r\n    };\r\n    Quat.prototype.conjugate = function () {\r\n        this.values[0] *= -1;\r\n        this.values[1] *= -1;\r\n        this.values[2] *= -1;\r\n        return this;\r\n    };\r\n    Quat.prototype.length = function () {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    };\r\n    Quat.prototype.normalize = function (dest) {\r\n        if (!dest) {\r\n            dest = this;\r\n        }\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var length = Math.sqrt(x * x + y * y + z * z + w * w);\r\n        if (!length) {\r\n            dest.x = 0;\r\n            dest.y = 0;\r\n            dest.z = 0;\r\n            dest.w = 0;\r\n            return dest;\r\n        }\r\n        length = 1 / length;\r\n        dest.x = x * length;\r\n        dest.y = y * length;\r\n        dest.z = z * length;\r\n        dest.w = w * length;\r\n        return dest;\r\n    };\r\n    Quat.prototype.add = function (other) {\r\n        for (var i = 0; i < 4; i++) {\r\n            this.values[i] += other.at(i);\r\n        }\r\n        return this;\r\n    };\r\n    Quat.prototype.multiply = function (other) {\r\n        var q1x = this.values[0];\r\n        var q1y = this.values[1];\r\n        var q1z = this.values[2];\r\n        var q1w = this.values[3];\r\n        var q2x = other.x;\r\n        var q2y = other.y;\r\n        var q2z = other.z;\r\n        var q2w = other.w;\r\n        this.x = q1x * q2w + q1w * q2x + q1y * q2z - q1z * q2y;\r\n        this.y = q1y * q2w + q1w * q2y + q1z * q2x - q1x * q2z;\r\n        this.z = q1z * q2w + q1w * q2z + q1x * q2y - q1y * q2x;\r\n        this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\r\n        return this;\r\n    };\r\n    Quat.prototype.multiplyVec3 = function (vector, dest) {\r\n        if (!dest) {\r\n            dest = new V3();\r\n        }\r\n        var x = vector.x;\r\n        var y = vector.y;\r\n        var z = vector.z;\r\n        var qx = this.x;\r\n        var qy = this.y;\r\n        var qz = this.z;\r\n        var qw = this.w;\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n        dest.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        dest.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        dest.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n        return dest;\r\n    };\r\n    Quat.prototype.toMat3 = function (dest) {\r\n        if (!dest) {\r\n            dest = new M3();\r\n        }\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n        dest.init([\r\n            1 - (yy + zz),\r\n            xy + wz,\r\n            xz - wy,\r\n            xy - wz,\r\n            1 - (xx + zz),\r\n            yz + wx,\r\n            xz + wy,\r\n            yz - wx,\r\n            1 - (xx + yy),\r\n        ]);\r\n        return dest;\r\n    };\r\n    Quat.prototype.toMat4 = function (dest) {\r\n        if (!dest) {\r\n            dest = new M4();\r\n        }\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n        dest.init([\r\n            1 - (yy + zz),\r\n            xy + wz,\r\n            xz - wy,\r\n            0,\r\n            xy - wz,\r\n            1 - (xx + zz),\r\n            yz + wx,\r\n            0,\r\n            xz + wy,\r\n            yz - wx,\r\n            1 - (xx + yy),\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            1,\r\n        ]);\r\n        return dest;\r\n    };\r\n    Quat.identity = new Quat().setIdentity();\r\n    Quat.zero = new Quat([0, 0, 0, 1]);\r\n    return Quat;\r\n}());\r\nexport { Quat };\r\n"],"sourceRoot":""}